{"version":3,"file":"static/chunks/47-9b6cad9124df939e.js","mappings":"AwEAA,aACA,CAACA,KAAK,gBAAmB,CAAGA,KAAK,gBAAmB,EAAI,EAAE,EAAEC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAEjE,MACC,SAASC,CAAuB,CAAEC,CAAmB,CAAEC,CAAmB,CAAE,CAInFA,EAAoBC,CAAC,CAACF,EAAqB,CACzC,GAAM,UAAW,CAAE,OAAsBG,EAAa,CACxD,GAKA,IvCdAC,EvBAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACAC,EoCAAC,EjCAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EsBKmCC,EAAAC,EAQ/BC,EAAQnB,EAAoB,MhCdhC,+BAEA,SAAAoB,EAAkBhB,CAAA,EAClB,QAAAiB,EAAA,EAAAA,EAAAC,UAAAC,MAAA,CAAAF,IAAA,CACA,IAAAG,EAAAF,SAAA,CAAAD,EAAA,CACA,QAAAI,KAAAD,EACApB,CAAA,CAAAqB,EAAA,CAAAD,CAAA,CAAAC,EAAA,CAGA,OAAArB,CACA,EAwHAsB,SAlGAA,EAAAC,CAAA,CAAAC,CAAA,EACA,SAAAC,EAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,uBAAAC,UAMA,gBAAAD,CAH0BA,EAAAZ,EAAA,GAAAQ,EAAAI,EAAA,EAG1BE,OAAA,EACAF,CAAAA,EAAAE,OAAA,KAAAC,KAAAA,KAAAC,GAAA,GAAAJ,MAAAA,EAAAE,OAAA,GAEAF,EAAAE,OAAA,EACAF,CAAAA,EAAAE,OAAA,CAAAF,EAAAE,OAAA,CAAAG,WAAA,IAGAP,EAAAQ,mBAAAR,GACAS,OAAA,wBAAAC,oBAAAD,OAAA,SAAAE,QAGA,IAAAC,EAAA,GACA,QAAAC,KAAAX,EACAA,CAAA,CAAAW,EAAA,GAGkCD,GAAA,KAAAC,EAGlC,KAAAX,CAAA,CAAAW,EAAA,EAWAD,CAAAA,GAAA,IAAAV,CAAA,CAAAW,EAAA,CAAAC,KAAA,WAGA,OAAAX,SAAAY,MAAA,CACAf,EAAA,IAAAH,EAAAmB,KAAA,CAAAf,EAAAD,GAAAY,EAvCA,CAoEA,OAAAK,OAAAC,MAAA,CACA,CACAnB,IAAAA,EACAoB,IA7BA,SAAAnB,CAAA,EACA,uBAAAG,UAAAX,CAAAA,CAAAA,UAAAC,MAAA,EAAAO,CAAA,GAQA,QAFAoB,EAAAjB,SAAAY,MAAA,CAAAZ,SAAAY,MAAA,CAAAD,KAAA,UACAO,EAAA,GACA9B,EAAA,EAAAA,EAAA6B,EAAA3B,MAAA,CAAAF,IAAA,CACA,IAAA+B,EAAAF,CAAA,CAAA7B,EAAA,CAAAuB,KAAA,MAAAb,EAAAqB,EAAAC,KAAA,IAAAC,IAAA,MAGA,IACA,IAAAC,EAAAf,mBAAAY,CAAA,KAGA,GAHAD,CAAA,CAAAI,EAAA,CAAA5B,EAAA6B,IAAA,CAAAzB,EAAAwB,GAGAzB,IAAAyB,EACA,MAEA,MAAAE,EAAA,GAGA,OAAA3B,EAAAqB,CAAA,CAAArB,EAAA,CAAAqB,CAAA,CArBA,EA4BAO,OAAA,SAAA5B,CAAA,CAAAE,CAAA,EACAH,EACAC,EACU,GACVV,EAAA,GAAAY,EAAA,CACWE,QAAA,EACX,GAEA,EACAyB,eAAA,SAAA3B,CAAoC,EAC7B,OAAAN,EAAA,KAAAC,SAAA,CAAAP,EAAA,QAAAY,UAAA,CAAAA,GACP,EACA4B,cAAoB,SAAAjC,CAAS,EAC7B,OAAAD,EAAAN,EAAA,QAAAO,SAAA,CAAAA,GAAA,KAAAK,UAAA,CACK,CACL,EACA,CACAA,WAAA,CAAmBD,MAAAgB,OAAAc,MAAA,CAAAjC,EAAA,EACnBD,UAAA,CAAAI,MAAAgB,OAAAc,MAAA,CAAAlC,EAAA,CACA,EACA,EAjHA,CACA6B,KAAA,SAAAzB,CAAA,EAIG,MAHH,MAAAA,CAAA,KACAA,CAAAA,EAAAA,EAAAsB,KAAA,QAEGtB,EAAAQ,OAAA,oBAAAC,mBACH,EACAM,MAAA,SAAAf,CAAA,EACA,OAAAO,mBAAAP,GAAAQ,OAAA,CACA,2CACAC,mBAEA,CACA,EAuGA,CAAAsB,KAAA,MM3HA,IAAAC,EAAA/D,EAAA,OAAAgE,EAAAhE,EAAA,OAAAiE,EAAAjE,EAAA,MGPkBkE,EAAAnB,OAAAkB,cAAA,CAIlB,SAAAE,EAAA/D,CAAA,CAAAqB,CAAA,CAAAlB,CAAA,EACA,IAAA6D,EAAA7D,EAAA6D,YAAA,CACAC,EAAA9D,EAAA8D,UAAA,CACAC,EAAA/D,EAAA+D,WAAA,CAAAvC,EAAAxB,EAAAwB,KAAA,CAGA,OACAqC,aAAAA,EAAAC,WAAAA,EAGApB,IAAA,WAGA,UAAA7C,GAGA,IAAAmE,EAAAD,EAAAA,EAAAE,IAAA,OAAAzC,CAAA,CAUK,OAPLmC,EAAA,KAAAzC,EAAA,CACA2C,aAAAA,EACAC,WAAAA,EACAI,SAAA,GACO1C,MAAAwC,CAAA,GAGFA,EAZL,EAgBA1C,IAAA6C,EAAAjD,EACA,EAGA,SAAAkD,GAAA,CACA,QAAAC,EAAAtD,UAAAC,MAAA,CAAAsD,EAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IACAF,CAAA,CAAAE,EAAA,CAAAzD,SAAA,CAAAyD,EAAA,CAGA,OAAAC,EAAAb,EAAAU,EAAA,CC5C6I,IAAAI,EAAA,mBAAAC,QAAA,iBAAAA,OAAAC,QAAA,UAAAC,CAAA,gBAAAA,CAAA,WAAAA,CAAA,SAAAA,GAAA,mBAAAF,QAAAE,EAAAC,WAAA,GAAAH,QAAAE,IAAAF,OAAAI,SAAA,iBAAAF,CAAA,EAK7I,SAAAG,EAAAnF,CAAA,CAAAC,CAAA,CAAAE,CAAA,CAAAC,CAAA,EACAD,GACAwC,OAAAkB,cAAA,CAAA7D,EAAAC,EAAA,CACAgE,WAAA9D,EAAA8D,UAAA,CACAD,aAAA7D,EAAA6D,YAAA,CACAK,SAAAlE,EAAAkE,QAAA,CACG1C,MAAAxB,EAAA+D,WAAA,CAAA/D,EAAA+D,WAAA,CAAAE,IAAA,CAAAhE,GAAA,QACH,CAKA,SAAAgF,EAAApF,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,EACA,IAAAC,EAAA,GAyBA,OAxBAsC,OAAA,KAAAxC,GAAAkF,OAAA,UAAAhE,CAAA,EACGhB,CAAA,CAAAgB,EAAA,CAAAlB,CAAA,CAAAkB,EAAA,GAEHhB,EAAA4D,UAAA,GAAA5D,EAAA4D,UAAA,CAAA5D,EAAA2D,YAAA,GAAA3D,EAAA2D,YAAA,CAGA,WAAA3D,GAAAA,EAAA6D,WAAA,GACA7D,CAAAA,EAAAgE,QAAA,KAGAhE,EAAAH,EAAA+C,KAAA,GAAAqC,OAAA,GAAAC,MAAA,UAAAlF,CAAA,CAAAmF,CAAA,EACG,OAAAA,EAAAxF,EAAAC,EAAAI,IAAAA,CAAA,EAAAA,GAGHD,GAAAC,KAAA,IAAAA,EAAA6D,WAAA,GACA7D,EAAAsB,KAAA,CAAAtB,EAAA6D,WAAA,CAAA7D,EAAA6D,WAAA,CAAAE,IAAA,CAAAhE,GAAA,OACAC,EAAA6D,WAAA,CAAAuB,KAAAA,GAGA,SAAApF,EAAA6D,WAAA,GACAvB,OAAA,eAAA3C,EAAAC,EAAAI,GACAA,EAAA,MAGAA,CAAA,CAMwK,SAAAqF,EAAAC,CAAA,MAAAjB,MAAAkB,OAAA,CAAAD,GAAA,OAAAjB,MAAAmB,IAAA,CAAAF,EAAA,SAAA1E,EAAA,EAAA6E,EAAApB,MAAAiB,EAAAxE,MAAA,EAAAF,EAAA0E,EAAAxE,MAAA,CAAAF,IAAA6E,CAAA,CAAA7E,EAAA,CAAA0E,CAAA,CAAA1E,EAAA,QAAA6E,CAAA,CAKxK,IAAAC,EAAApD,OAAAkB,cAAA,CACAmC,EAAArD,OAAAqD,wBAAA,CACAC,EAAAtD,OAAAsD,mBAAA,CAAAC,EAAAvD,OAAAuD,qBAAA,CAoBA,SAAAtB,EAAAb,CAAA,CAAAoC,CAAA,QACA,CAAAC,SAjBA/F,CAAA,EACA,IAAAA,GAAA,CAAAA,EAAAgG,cAAA,CACA,SAKA,QAHAC,EAAA,oCAGArF,EAAA,EAAAsF,EAAAD,EAAAnF,MAAA,CAAAF,EAAAsF,EAAAtF,IACA,GAAAZ,EAAAgG,cAAA,CAAAC,CAAA,CAAArF,EAAA,EACA,QACA,CAGA,UAIAkF,CAAA,CAAAA,EAAAhF,MAA6C,KAG7C,WACA,OAAA4C,EAAAyC,KAAA,CAAAf,KAAAA,EAAAC,EAAAhB,MAAAQ,SAAA,CAAAjC,KAAA,CAAAmB,IAAA,CAAAlD,YAAAuF,MAAA,EAAAN,EAAA,EACA,EAJIpC,EAAAyC,KAAA,CAAAf,KAAAA,EAAAC,EAAAS,GAAAM,MAAA,OAKJ,CAGA,IAAAC,EAAAnG,CAAAA,EAYA6E,EAAA7E,CAZAA,EAAA,SAAAmG,GAAA,CAAAC,CAxE4F,SAAAC,CAAA,CAAAC,CAAA,MAAAD,CAAAA,aAAAC,CAAA,yDAwE5F,KAAAH,GAEAvB,EAAA,0BAAA3E,EAAA,MAEA2E,EAAA,0BAAA1E,EAAA,MAEA0E,EAAA,kCAAAzE,EAAA,MAEAyE,EAAA,4BAAAxE,EAAA,MAGCwE,EAAiB,sBAAAvE,EAAyB,KAC3C,GAAAsE,SAAA,uBAAAX,EAAA,EACAN,WAAA,GACAC,YAAA,WACA,QACC,CACD,GAAAzD,EAAA2E,EAAA7E,EAAA2E,SAAA,uBAAAX,EAAA,EACAN,WAAA,GACAC,YAAA,WACA,QACC,CACD,GAAAxD,EAAA0E,EAAA7E,EAAA2E,SAAA,+BAAAX,EAAA,EACAN,WAAA,GACAC,YAAA,WACA,QACC,CACD,GAAAvD,EAAAyE,EAAA7E,EAAA2E,SAAA,yBAAAX,EAAA,EACAN,WAAA,GACAC,YAAA,WACA,YAEA,GAAAtD,EAAAwE,EAAA7E,EAAA2E,SAAA,mBAAAX,EAAA,EACAN,WAAA,GACAC,YAAA,WACA,YACC,GAAA3D,CAAA,EAGDuG,EAAA,mBAAAhC,OAAAA,OAAA,6CAcAiC,EAAAb,EAAA,SAAAc,CAAA,EACE,OAAAf,EAAAe,GAAAP,MAAA,CAAAP,EAAAc,GAAA,EAAAf,CAAA,CAaF,SAAA3B,EAAAjD,CAAA,EACA,gBAAA4F,CAAA,EASA,OARAtE,OAAAkB,cAAA,MAAAxC,EAAA,CACA2C,aAAA,GACAK,SAAA,GAEAJ,WAAA,GACKtC,MAAAsF,CAAA,GAGLA,CACA,EAGA,SAAAC,EAAAC,CAAA,CAAA/G,CAAA,SACA,EAAA8G,IAAA,CACIC,EAAAD,IAAA,CAAA9G,GAEJ,WACA,OAAA+G,EAAAX,KAAA,CAAApG,EAAAc,UACA,CACA,CAGA,IAAAkG,EACA,qBAAAC,QAAA,YAAAxC,EAAAwC,QAAA,cAAAA,SAAA,mBAAAA,QAAAC,IAAA,CAGAJ,EAAAG,QAAAC,IAAA,CAAAD,SAFI,YAGH,CCtL4IE,EAAA,mBAAAzC,QAAA,iBAAAA,OAAAC,QAAA,UAAAC,CAAA,gBAAAA,CAAA,WAAAA,CAAA,SAAAA,GAAA,mBAAAF,QAAAE,EAAAC,WAAA,GAAAH,QAAAE,IAAAF,OAAAI,SAAA,iBAAAF,CAAA,EAEoawC,EAAA,oBAAAC,EAAAzH,CAAA,CAAA0H,CAAA,UAAAzG,EAAA,EAAAA,EAAAyG,EAAAvG,MAAA,CAAAF,IAAA,KAAAd,EAAAuH,CAAA,CAAAzG,EAAA,CAAAd,EAAA8D,UAAA,CAAA9D,EAAA8D,UAAA,KAAA9D,EAAA6D,YAAA,cAAA7D,GAAAA,CAAAA,EAAAkE,QAAA,KAAA1B,OAAAkB,cAAA,CAAA7D,EAAAG,EAAAkB,GAAA,CAAAlB,EAAA,kBAAA0G,CAAA,CAAAc,CAAA,CAAAC,CAAA,SAAAD,GAAAF,EAAAZ,EAAA3B,SAAA,CAAAyC,GAAAC,GAAAH,EAAAZ,EAAAe,GAAAf,CAAA,KAOjjBgB,EAAA,kFITwK,SAAAC,EAAAnC,CAAA,MAAAjB,MAAAkB,OAAA,CAAAD,GAAA,OAAAjB,MAAAmB,IAAA,CAAAF,EAAA,SAAA1E,EAAA,EAAA6E,EAAApB,MAAAiB,EAAAxE,MAAA,EAAAF,EAAA0E,EAAAxE,MAAA,CAAAF,IAAA6E,CAAA,CAAA7E,EAAA,CAAA0E,CAAA,CAAA1E,EAAA,QAAA6E,CAAA,EJYxK,WA8EA,SAAIiC,EAAeC,CAAA,CAAAC,CAAA,CAAAC,CAAA,CAAAC,CAAA,GAAAC,SAtFyExB,CAAA,CAAAC,CAAA,MAAAD,CAAAA,aAAAC,CAAA,wDAsFzE,KAAAkB,GAGnB,KAAAC,WAAA,CAAAA,EACA,KAAAC,UAAA,CAAAA,EACA,KAAAC,gBAAA,CAAAA,EACA,KAAAC,eAAA,CAAAA,CAAA,CAnFAX,EAAAO,EAAA,EACA1G,IAAA,YACAM,MAAA,SAAAxB,CAAA,SACA,KAAAsF,IAAAtF,EACA,KAGA,UAAAA,EACAA,EAAAwB,KAAA,CAGA,QAAAxB,EACAA,EAAA0C,GAAA,CAGA,QAAA1C,EACAA,EAAAsB,GAAA,OAZA,CAeA,GACAJ,IAAA,yBACAM,MAAA,SAAA0G,CAAA,QACA,UAAAA,EAAA,YAAAd,EAAAc,EAAA,IACA,WACA,KAAAC,yBAAA,CAAAD,GAEA,KAAAhH,GAAA,CAGA,GACAA,IAAA,4BACAM,MAAA,SAAAwF,CAAA,MAAAoB,EAAA,KAGA,OAAApB,EAAAqB,QAAA,GAAArG,OAAA,CAAA0F,EAAA,SAAAY,CAAA,EACA,IAAA/G,EAAAR,UAAAC,MAAA,IAAAD,KAAAuE,IAAAvE,SAAA,IAAAA,SAAA,IAAAqH,EAAAlH,GAAA,CACAqH,EAAAxH,SAAA,IACO,OAAAQ,EAAAgH,CACP,EACG,CACH,GACArH,IAAA,MACAwB,IAAA,WACA,YAAAsF,eAAA,CAAA9G,GAAA,CAEA,GACAA,IAAA,iBACAwB,IAAA,WACA,YAAAmF,WAAA,CAAA/C,WAAA,CAAAvD,IAAA,UAAAiH,uBAAA,CAEA,GACAtH,IAAA,gBACAwB,IAAA,WACA,YAAAoF,UAAA,CAAAhD,WAAA,CAAAvD,IAAA,UAAAkH,sBAAA,CAEA,GACAvH,IAAA,cACAwB,IAAA,WACA,YAAAgG,SAAA,MAAAX,gBAAA,CACG,CACH,GACA7G,IAAA,aACAwB,IAAA,WACA,YAAAgG,SAAA,MAAAV,eAAA,CACG,CACH,GACA9G,IAAA,0BACAwB,IAAA,WACA,YAAAiG,sBAAA,MAAAC,WAAA,CACG,CACH,GACA1H,IAAA,yBACAwB,IAAA,WACA,YAAAiG,sBAAA,MAAAE,UAAA,CACG,KAYHxB,EAAAO,EAAA,EACA1G,IAAA,SACAM,MAAA,SAAAsH,CAAA,MAAAC,EAAAhI,UAAAC,MAAA,IAAAD,KAAAuE,IAAAvE,SAAA,IAAAA,SAAA,QAGA,IAAA+H,GACA,KAAAE,KAAA,CAAAC,8CAAAF,EAEG,CACH,GACA7H,IAAA,QACAM,MAAA,SAAAuH,CAAA,MAAAG,EAAA,WAWA,YARAH,EAAAA,EAGA/G,OAAA,qBAAAmH,CAAA,EACO,OAAAD,EAAYE,cAAM,GACzBpH,OAAA,oBAAAmH,CAAA,EACO,OAAAD,EAAAG,aAAA,GAEP,CACG,GAGF,IIzHD,IAAAC,EAAA9G,OAAAkB,cAAA,CAAA6F,EAAA/G,OAAA+G,cAAA,CAGAC,EAAA,OAyBA,SAAAC,EAAcC,CAAA,EAId,QL2GA7E,EAAA8E,EK9GAA,GL8GA9E,EK9GuB6E,EAAA3E,SAAA,CL8GvB4E,EAAA,GAGA/C,EAAA/B,GAAAK,OAAA,UAAAhE,CAAA,EACG,OAAAyI,CAAA,CAAAzI,EAAA,CAAA2E,EAAAhB,EAAA3D,EAAA,GAGHyI,GKrHuBxD,EAAAS,EAAA+C,GAGvB7I,EAAA,EAAAsF,EAAAD,EAAAnF,MAAA,CAAAF,EAAAsF,EAAAtF,IAAA,CACA,IAAAI,EAAAiF,CAAA,CAAArF,EAAA,CAAAZ,EAAAyJ,CAAA,CAAAzI,EAAA,CAGA,mBAAAhB,EAAAsB,KAAA,EAAAN,gBAAAA,GAIAoI,EAAAI,EAAA3E,SAAA,CAAA7D,EAAA0I,EAAAF,EAAA3E,SAAA,CAAA7D,EAAAhB,GACA,EAGA,SAAA0J,EAAA/J,CAAA,CAAAqB,CAAA,CAAA2I,CAAA,EACA,IAAA7C,EAAA6C,EAAArI,KAAA,CACAqC,EAAAgG,EAAAhG,YAAA,CAAAC,EAAA+F,EAAA/F,UAAA,CAGA,sBAAAkD,EACA,mEAAAA,EAAA,CAEA,IAAAlC,EAAAjF,EAAAiF,WAAA,CAIA,OACAjB,aAAAA,EAAAC,WAAAA,EAGApB,IAAA,WAIA,UAAA7C,GAQA,KAAAiF,WAAA,GAAAA,GAAAyE,EAAA,MAAAzE,WAAA,GAAAA,EAPA,OAAAkC,CAAA,CAYA,QAAAlC,WAAA,GAAAA,GAAA5D,KAAA,KAAA4D,WAAA,CAAAC,SAAA,CACA,OAAA+E,SAxEAjF,CAAA,CAAAmC,CAAA,EACA,uBAAA+C,QACA,kCAAA/C,EAAAzF,IAAA,wDAAAyF,EAAAzF,IAAA,4EAGAiI,GACAA,CAAAA,EAAA,IAAAO,OAAA,EAGA,KAAAP,EAAAQ,GAAA,CAAAnF,IACA2E,EAAAlI,GAAA,CAAAuD,EAAA,IAAAkF,SAEA,IAAAE,EAAAT,EAAA9G,GAAA,CAAAmC,GAOA,MAJ2B,KAA3BoF,EAAAD,GAAA,CAAAhD,IACAiD,EAAA3I,GAAA,CAAA0F,EAAAD,EAAAC,EAAAnC,IAGAoF,EAAAvH,GAAA,CAAAsE,EAAA,EAqDA,KAAAA,EAAA,CAEwB,IAAAkD,EAAAnD,EAAAC,EAAA,MAWnB,OARLsC,EAAA,KAAApI,EAAA,CACA2C,aAAA,GACAK,SAAA,GAEAJ,WAAA,GACOtC,MAAA0I,CAAA,GAGFA,CAAA,EAGL5I,IAAA6C,EAAAjD,EACA,EChGA,SAAAiJ,EAAAtK,CAAA,CAAAqB,CAAA,CAAAlB,CAAA,EAEA,OADAA,EAAAkE,QAAA,IACAlE,CAAA,CQMAkH,QAAAkD,IAAA,EAAAlD,QAAAkD,IAAA,CAAArD,IAAA,CAAAG,SAGAA,QAAAmD,OAAA,EAAAnD,QAAAmD,OAAA,CAAAtD,IAAA,CAAAG,SEdgP,IAAAoD,EAAA9H,OAAA+H,MAAA,WAAA1K,CAAA,UAAAiB,EAAA,EAAAA,EAAAC,UAAAC,MAAA,CAAAF,IAAA,KAAAG,EAAAF,SAAA,CAAAD,EAAA,SAAAI,KAAAD,EAAAuB,OAAAuC,SAAA,CAAAmB,cAAA,CAAAjC,IAAA,CAAAhD,EAAAC,IAAArB,CAAAA,CAAA,CAAAqB,EAAA,CAAAD,CAAA,CAAAC,EAAA,SAAArB,CAAA,EAEqa2K,EAAA,SAAAhF,CAAA,CAAA1E,CAAA,KAAAyD,MAAAkB,OAAA,CAAAD,GAAA,OAAAA,CAAA,IAAAb,OAAAC,QAAA,IAAApC,OAAAgD,GAAA,OAAAiF,SAAAjF,CAAA,CAAA1E,CAAA,MAAA4J,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAAvF,KAAAA,EAAA,YAAAwF,EAAAC,EAAAvF,CAAA,CAAAb,OAAAC,QAAA,KAAA+F,CAAAA,EAAA,CAAAG,EAAAC,EAAAC,IAAA,IAAAC,IAAA,IAAAP,EAAApL,IAAA,CAAAwL,EAAAtJ,KAAA,EAAAV,CAAAA,GAAA4J,EAAA1J,MAAA,GAAAF,GAAA6J,EAAA,WAAAO,EAAA,CAAAN,EAAA,GAAAC,EAAAK,CAAA,cAAAP,GAAAI,EAAA,QAAAA,EAAA,oBAAAH,EAAA,MAAAC,CAAA,SAAAH,CAAA,EAAAlF,EAAA1E,EAAA,0EAQrpBqK,GAA6B,CAC7BC,QAAAlE,QAAAkE,OAAA,CAAArE,EAAAG,QAAuCkE,OAAA,CAAAlE,SAAA,aACvCmE,WAAQnE,QAAImE,UAAA,CAAAtE,EAAAG,QAAAmE,UAAA,CAAAnE,SAAA,aACZC,KAAAF,CAAA,EAGA,SAAAqE,GAAczL,CAAc,CAAAqB,CAAA,CAAAlB,CAAA,CAAA6J,CAAA,EAC5B,IAAA0B,EAAAf,EAAAX,EAAA,GACA2B,EAAAD,CAAA,IACAE,EAAAD,KAAAlG,IAAAkG,EAAA,KAAAA,CAAA,CACAE,EAAAH,CAAA,IACAI,EAAAD,KAAApG,IAAAoG,GAAAA,EACAE,EAAAL,CAAA,IAAsDrE,EAAA0E,KAAAtG,IAAAsG,EAAAT,GAAAS,CAAA,CAGtD,IAAAR,GAAAS,SAAA,CAKA,OAJAT,GAAAU,QAAA,GACA5E,EAAAC,IAAA,4EACAiE,GAAAU,QAAA,KAEA9L,CAAA,CAEA,IAAAgH,EAAAhH,EAAAwB,KAAA,CAOA,GAJA,OAAAiK,GACAA,CAAAA,EAAA5L,EAAAiF,WAAA,CAAAvD,IAAA,KAAAL,CAAA,EAGA,mBAAA8F,EACA,kEAAAA,EAAA,CAGA,OAAAsD,EAAA,GAAAtK,EAAA,CACAwB,MAAA,WACA,IAAAK,EAAAD,KAAiBC,GAAA,GACjBkK,GhBmFkB,KAAdlH,IgBnFJ,ChBmFIqB,cAAc,CAAAS,IAClBf,EgBpFA,KhBoFAe,EAAA,CAEKnF,MAAA,IAAA+E,CACL,GAGA1B,IgB1FA,ChB0FA8B,EAAA,EgBzFAgF,CAAAA,CAAA,IAAAA,GAAA,CAAAI,EAAAC,cAAA,EAAAL,CAAA,IAAAA,GAAA,iBAAAA,GAAA9J,EAAAkK,EAAAC,cAAA,CAAAL,GAAA,mBAAAA,GAAAA,EAAAtF,KAAA,MAAAtF,UAAA,IACAmG,EAAAkE,OAAA,CAAAK,GACAM,EAAAC,cAAA,CAAAnK,GAGA,IACQ,OAAAmF,EAAAX,KAAA,MAAAtF,UACR,SACAmG,EAAAmE,UAAA,CAAAI,EACA,CACG,CACH,GAGA,SAAAL,IAAA,CACA,QAAA/G,EAAAtD,UAAAC,MAAA,CAAAsD,EAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IACAF,CAAA,CAAAE,EAAA,CAAAzD,SAAA,CAAAyD,EAAA,CAGA,OAAAC,EAAA6G,GAAAhH,EAAA,CAKA8G,GAAAS,SAAA,GAAA3E,QAAAkE,OAAA,CAAAA,GAAAU,QAAA,IGtEA,IAAAG,GAAA,WACA,0BAAAC,MACA,ECFAtM,IACAA,CADAA,EAII,GAHJ,CAAAA,EAAA,mBACAA,CAAA,CAAAA,EAAA,qBACAA,CAAA,CAAAA,EAAA,iBACIA,GCFJ,GAAAuM,KAAA,CACA,IAAAC,GAAA/M,KACA+M,GAAAC,gBAAA,oBAAAC,CAAA,EACA,IAAAC,EAAAD,EAAAC,IAAA,CACA,OAAWA,EAAAC,IAAA,EACX,KAAA5M,GAAA6M,MAAA,CAEA,IAAAC,EAAAC,WAAA,WACAP,GAAAQ,WAAA,EACAC,OAAoBN,EAAAM,MAAA,CACPL,KAAA5M,GAAAkN,OAAA,GAEFC,aAAAL,EACX,EAAAH,EAAAS,IAAA,EACAZ,GAAAQ,WAAA,EACAC,OAAAN,EAAAM,MAAA,CACAI,MAAkBP,EACPF,KAAA5M,GAAA6M,MAAA,GAEX,WAEA7M,GAAAsN,KAAA,CAEAH,aAAAR,EAAAY,OAAA,EACAf,GAAAQ,WAAA,EACAC,OAAkBN,EAAAM,MAAa,CACpBL,KAAA5M,GAAAsN,KAAA,EAIR,CACH,EACA,KCvBAE,GAAA,EAMAC,GAAA,SAAAb,CAAA,CAAAK,CAAA,EACA,OACAL,KAAAA,EACAK,OAAAA,CACA,CACA,GACAS,UjBsFA,CACA,QATAhJ,EASAD,EAAAtD,UAAAC,MAAA,CAAAsD,EAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IACAF,CAAA,CAAAE,EAAA,CAAAzD,SAAA,CAAAyD,EAAA,CAGA,IAAAF,EAAAtD,MAAA,EAZA,KAAAsD,CADAA,EAkBAA,GAjBAtD,MAAA,CACIyI,EAAApD,KAAA,CAAAf,KAAAA,EAAAqC,EAAArD,IAEJsF,EAAAvD,KAAA,CAAAf,KAAAA,EAAAqC,EAAArD,GACA,CAcA,EiBjGA5D,CAAAA,EA2EAA,CA3EAA,EAAA,WACA,SAAI6M,GAAA,K1BxBJvN,E0ByBI,GAAAwD,EAAAgK,CAAA,EAAe,KAAAD,GACf,GAAA7J,EAA0B8J,CAAA,iBAAiB,IAAAC,M1B1B/CzN,E0B2BAW,I1BzBA6B,OAAAkB,cAAA,C0ByBA,c1BzBA,CACAI,WAAA9D,EAAA8D,UAAA,CACAD,aAAA7D,EAAA6D,YAAA,CACAK,SAAAlE,EAAAkE,QAAA,CACG1C,MAAAxB,EAAA+D,WAAA,CAAA/D,EAAA+D,WAAA,CAAAE,IAAA,C0BqBH,M1BrBG,S0BsBH,KAAA9C,IAAA,EACE,CAoED,MAnED,GAAAsC,EAAA+J,CAAA,EAAAD,EAAA,EACArM,IAAA,OACAM,MAAA,WACA,KAAAkM,SAAA,EACG,CACH,GACAxM,IAAA,aACAM,MAAA,SAAAmM,CAAA,EACA,IAAAvF,EAAA,KACA4E,EAAAjM,UAAAC,MAAA,IAAAD,KAAAuE,IAAAvE,SAAA,IAAAA,SAAA,MACA6M,EA3BA,CACAf,OAAAO,IACA,CA0BAQ,CAAAA,EAAAC,OAAA,CAAAF,EACA,KAAAG,OAAA,CAAAxM,GAAA,CAAAsM,EAA0Bf,MAAA,CAAAe,GAC1B,IAAA7E,EAAAsE,GAAAzN,GAAA6M,MAAA,CAAAmB,EAAAf,MAAA,EAGA,OAFA9D,EAAAiE,IAAA,CAAAA,EACA,KAAAe,MAAA,CAAAnB,WAAA,CAAA7D,GACA,WACAX,EAAA4F,KAAA,CAAAJ,EAAAf,MAAA,CACA,CACG,CACH,GACA3L,IAAA,QACAM,MAAU,SAAQyM,CAAA,EAClB,GxBpDC,oBAAA5F,SAAApE,IAAA,CwBoDDgK,IxBpDC,CAAAC,OAAAC,KAAA,CwBoDDF,IAAA,KAAAH,OAAA,CAAA9D,GAAA,CAAAiE,GAAA,CAEA,IADAG,EACArF,EAAAsE,GAAAzN,GAAA6M,MAAA,CAAAwB,EACAlF,CAAAA,EAAAkE,KAAA,QAAAmB,CAAAA,EAAA,KAAAN,OAAA,CAAApL,GAAA,CAAAuL,EAAA,GAAAG,KAAA,IAAAA,EAAA,OAAAA,EAAAnB,KAAA,CACA,KAAAc,MAAA,CAAAnB,WAAA,CAAA7D,EACA,EAEA,GACA7H,IAAA,YACAM,MAAA,WACA,IAAA0H,EAAA,KACA,KAAA6E,MAAA,CAAAM,SAAA,UAAAC,CAAA,EACA,IAAA/B,EAAA+B,EAAA/B,IAAA,CACA,OAAeA,EAAAC,IAAA,EACf,KAAA5M,GAAA6M,MAAA,CAEA,IAAA8B,EAAArF,EAAA4E,OAAA,CAAApL,GAAA,CAAA6J,EAAAM,MAAA,EACA,IAAA0B,EACA,MACA,CACAA,EAAAtB,KAAA,CAAAV,EAAAU,KAAA,CACA/D,EAAA4E,OAAA,CAAAxM,GAAA,CAAAiL,EAAAM,MAAA,CAAA0B,GACA,WAEA3O,GAAAkN,OAAA,CAGA,IADA0B,EACAC,EAAAvF,EAAA4E,OAAA,CAAApL,GAAA,CAAA6J,EAAAM,MAAA,EACA,IAAA4B,EACA,MACA,CACA,OAAAD,CAAAA,EAAAC,EAAAZ,OAAA,GAAAW,KAAA,IAAAA,GAAAA,EAAAvK,IAAA,CAAAwK,GACAvF,EAAA4E,OAAA,CAAAY,MAAA,CAAAD,EAAA5B,MAAA,EACA,WAEAjN,GAAAsN,KAAA,CAEAhE,EAAA4E,OAAA,CAAAY,MAAA,CAAAnC,EAAAM,MAAA,CAGA,CACA,CACG,CACH,IACMU,CACN,KAAAxI,SAAA,CzBlGAjF,EyBkGA,SzBlGAC,EyBkGA,ChB3FA,WACA,QAAAsE,EAAAtD,UAAAC,MAAA,CAAAsD,EAAAC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IACAF,CAAA,CAAAE,EAAA,CAAAzD,SAAA,CAAAyD,EAAA,CAGA,OAAAC,EAAA0F,EAAA7F,EAAA,EgBsFA,CzBjGApE,EAAA,GACAsC,OAAA2D,IAAA,CAFAnG,EyBkGA,CACA6D,aAAA,GACAC,WAAA,GACAI,SAAA,GACAH,YAAe,UAAW,CAC1B,UDrEmB,OCqEnB,GACC,CACD,GzBvGAmB,OAAA,UAAAhE,CAAA,EACGhB,CAAA,CAAAgB,EAAA,CAAAlB,CAAA,CAAAkB,EAAA,GAEHhB,EAAA4D,UAAA,GAAA5D,EAAA4D,UAAA,CACA5D,EAAA2D,YAAA,GAAA3D,EAAA2D,YAAA,CACA,WAAA3D,GAAAA,EAAA6D,WAAA,GACA7D,CAAAA,EAAAgE,QAAA,KAEAhE,EAAAH,EAAA+C,KAAA,GAAAqC,OAAA,GAAAC,MAAA,UAAAlF,CAAA,CAAAmF,CAAA,EACG,OAAAA,EAAAxF,EAAAC,EAAAI,IAAAA,CACH,EAAAA,GACAD,GAAAC,KAAA,IAAAA,EAAA6D,WAAA,GACA7D,EAAAsB,KAAA,CAAAtB,EAAA6D,WAAA,CAAA7D,EAAA6D,WAAA,CAAAE,IAAA,CAAAhE,GAAA,OACAC,EAAA6D,WAAA,CAAAuB,KAAAA,GAEA,SAAApF,EAAA6D,WAAA,GACAvB,OAAAkB,cAAA,CAAA7D,EAAAC,EAAAI,GACAA,EAAA,MyB+EAS,EzB7EAT,EyBoFAQ,CAAA,GMvGA,IAAAiO,GAAAxC,KAAAD,OAAA,KAgBuBvM,GAfvB,SAAAiP,CAAA,CAAAf,CAAA,EACA,IAAAhO,EAAAkB,UAAAC,MAAA,IAAAD,KAAAuE,IAAAvE,SAAA,IAAAA,SAAA,IAAA4N,EAAA,CACEE,EAAA9N,UAASC,MAAA,GAAAD,SAAA,IAAAuE,KAAAA,CAAA,CACX,GAAA1E,EAAAkO,SAAA,aACA,GAAAjB,GAGAhO,EAIA,OADAA,EAAAwM,gBAAA,CAAAuC,EAAAf,EAAAgB,GACA,WACAhP,EAAAkP,mBAAA,CAAAH,EAAAf,EAAAgB,EACG,CAPH,EAQA,GACA,CKhBA1O,EADAA,EAKAA,QAAA,IAJA,UACAA,EAAA,YACAA,EAAA,kBULwCqC,OAAAuC,SAAA,CAAAsD,QAAA,CeoCW","sources":["webpack://_N_E/./node_modules/let-hooks/es/useAsyncEffect/index.js","webpack://_N_E/./node_modules/let-hooks/es/useBattery/index.js","webpack://_N_E/./node_modules/let-hooks/es/useBeforeUnload/index.js","webpack://_N_E/./node_modules/js-cookie/dist/js.cookie.mjs","webpack://_N_E/./node_modules/let-hooks/es/useEffectOnce/index.js","webpack://_N_E/./node_modules/let-hooks/es/useMount/index.js","webpack://_N_E/./node_modules/let-hooks/es/useCookie/index.js","webpack://_N_E/./node_modules/let-hooks/es/useCountdown/index.js","webpack://_N_E/./node_modules/let-hooks/es/useCounter/index.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js","webpack://_N_E/./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js","webpack://_N_E/./node_modules/let-hooks/es/utils/isNumber.js","webpack://_N_E/./node_modules/core-decorators/es/lazy-initialize.js","webpack://_N_E/./node_modules/core-decorators/es/private/utils.js","webpack://_N_E/./node_modules/core-decorators/es/override.js","webpack://_N_E/./node_modules/core-decorators/es/deprecate.js","webpack://_N_E/./node_modules/core-decorators/es/suppress-warnings.js","webpack://_N_E/./node_modules/core-decorators/es/memoize.js","webpack://_N_E/./node_modules/core-decorators/es/autobind.js","webpack://_N_E/./node_modules/core-decorators/es/readonly.js","webpack://_N_E/./node_modules/core-decorators/es/enumerable.js","webpack://_N_E/./node_modules/core-decorators/es/nonenumerable.js","webpack://_N_E/./node_modules/core-decorators/es/nonconfigurable.js","webpack://_N_E/./node_modules/core-decorators/es/debounce.js","webpack://_N_E/./node_modules/core-decorators/es/throttle.js","webpack://_N_E/./node_modules/core-decorators/es/decorate.js","webpack://_N_E/./node_modules/core-decorators/es/mixin.js","webpack://_N_E/./node_modules/core-decorators/es/time.js","webpack://_N_E/./node_modules/core-decorators/es/extendDescriptor.js","webpack://_N_E/./node_modules/core-decorators/es/profile.js","webpack://_N_E/./node_modules/core-decorators/es/applyDecorators.js","webpack://_N_E/./node_modules/core-decorators/es/core-decorators.js","webpack://_N_E/./node_modules/let-hooks/es/utils/isBrowser.js","webpack://_N_E/./node_modules/let-hooks/es/utils/work-timer/types.js","webpack://_N_E/./node_modules/let-hooks/es/utils/work-timer/timer.worker.js","webpack://_N_E/./node_modules/let-hooks/es/utils/work-timer/index.js","webpack://_N_E/./node_modules/let-hooks/es/utils/work-timer/helper.js","webpack://_N_E/./node_modules/let-hooks/es/useLatest/index.js","webpack://_N_E/./node_modules/let-hooks/es/useTimeoutFn/index.js","webpack://_N_E/./node_modules/let-hooks/es/useDebounce/index.js","webpack://_N_E/./node_modules/let-hooks/es/useDebounceFn/index.js","webpack://_N_E/./node_modules/let-hooks/es/useEvent/index.js","webpack://_N_E/./node_modules/let-hooks/es/useEventAway/index.js","webpack://_N_E/./node_modules/let-hooks/es/useFavicon/index.js","webpack://_N_E/./node_modules/let-hooks/es/useHash/index.js","webpack://_N_E/./node_modules/let-hooks/es/useHidden/index.js","webpack://_N_E/./node_modules/let-hooks/es/utils/history.js","webpack://_N_E/./node_modules/let-hooks/es/useHistory/index.js","webpack://_N_E/./node_modules/let-hooks/es/useIntersection/index.js","webpack://_N_E/./node_modules/let-hooks/es/useInterval/index.js","webpack://_N_E/./node_modules/let-hooks/es/useLocation/index.js","webpack://_N_E/./node_modules/let-hooks/es/useLRU/index.js","webpack://_N_E/./node_modules/let-hooks/es/useMap/index.js","webpack://_N_E/./node_modules/let-hooks/es/useMemoizedFn/index.js","webpack://_N_E/./node_modules/let-hooks/es/useMessage/index.js","webpack://_N_E/./node_modules/let-hooks/es/useMountedState/index.js","webpack://_N_E/./node_modules/let-hooks/es/utils/toString.js","webpack://_N_E/./node_modules/let-hooks/es/utils/isNetworkInformation.js","webpack://_N_E/./node_modules/let-hooks/es/useNetwork/index.js","webpack://_N_E/./node_modules/let-hooks/es/usePlatform/index.js","webpack://_N_E/./node_modules/let-hooks/es/useQueue/index.js","webpack://_N_E/./node_modules/let-hooks/es/useSet/index.js","webpack://_N_E/./node_modules/let-hooks/es/useStack/index.js","webpack://_N_E/./node_modules/let-hooks/es/useStyle/index.js","webpack://_N_E/./node_modules/let-hooks/es/useUpdate/index.js","webpack://_N_E/./node_modules/let-hooks/es/useTimeout/index.js","webpack://_N_E/./node_modules/let-hooks/es/useTitle/index.js","webpack://_N_E/./node_modules/let-hooks/es/useToggle/index.js","webpack://_N_E/./node_modules/let-hooks/es/useTyping/index.js","webpack://_N_E/./node_modules/let-hooks/es/useUnmount/index.js","webpack://_N_E/./node_modules/let-hooks/es/useUpdateEffect/index.js","webpack://_N_E/./node_modules/let-hooks/es/index.js","webpack://_N_E/<anon>"],"sourcesContent":["import _regeneratorRuntime from \"@babel/runtime/helpers/esm/regeneratorRuntime\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { useEffect } from 'react';\nimport isAsyncGenerator from \"../utils/isAsyncGenerator\";\nimport isFunction from \"../utils/isFunction\";\nvar useAsyncEffect = function useAsyncEffect(effect, deps) {\n  if (!isFunction(effect)) {\n    throw new Error('effect has to be a function, but got a ' + _typeof(effect));\n  }\n  useEffect(function () {\n    var cancelled = false;\n    var e = effect();\n    function execute() {\n      return _execute.apply(this, arguments);\n    }\n    function _execute() {\n      _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!isAsyncGenerator(e)) {\n                _context.next = 11;\n                break;\n              }\n            case 1:\n              if (!true) {\n                _context.next = 9;\n                break;\n              }\n              _context.next = 4;\n              return e.next();\n            case 4:\n              result = _context.sent;\n              if (!(result.done || cancelled)) {\n                _context.next = 7;\n                break;\n              }\n              return _context.abrupt(\"break\", 9);\n            case 7:\n              _context.next = 1;\n              break;\n            case 9:\n              _context.next = 13;\n              break;\n            case 11:\n              _context.next = 13;\n              return e;\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _execute.apply(this, arguments);\n    }\n    execute();\n    return function () {\n      cancelled = false;\n    };\n  }, deps);\n};\nexport default useAsyncEffect;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nvar useBattery = function useBattery() {\n  var _useState = useState({\n      isSupport: false\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useEffect(function () {\n    var batteryManager;\n    var updateState = function updateState() {\n      setState(function () {\n        var _batteryManager, _batteryManager2, _batteryManager3, _batteryManager4;\n        return {\n          isSupport: true,\n          level: (_batteryManager = batteryManager) === null || _batteryManager === void 0 ? void 0 : _batteryManager.level,\n          charging: (_batteryManager2 = batteryManager) === null || _batteryManager2 === void 0 ? void 0 : _batteryManager2.charging,\n          chargingTime: (_batteryManager3 = batteryManager) === null || _batteryManager3 === void 0 ? void 0 : _batteryManager3.chargingTime,\n          dischargingTime: (_batteryManager4 = batteryManager) === null || _batteryManager4 === void 0 ? void 0 : _batteryManager4.dischargingTime\n        };\n      });\n    };\n    if ('getBattery' in navigator) {\n      var _getBattery, _ref;\n      (_getBattery = (_ref = navigator).getBattery) === null || _getBattery === void 0 ? void 0 : _getBattery.call(_ref).then(function (battery) {\n        batteryManager = battery;\n        batteryManager.addEventListener('chargingchange', updateState);\n        batteryManager.addEventListener('levelchange', updateState);\n        batteryManager.addEventListener('chargingtimechange', updateState);\n        batteryManager.addEventListener('dischargingtimechange', updateState);\n        updateState();\n      });\n    }\n    return function () {\n      if (batteryManager) {\n        batteryManager.removeEventListener('chargingchange', updateState);\n        batteryManager.removeEventListener('levelchange', updateState);\n        batteryManager.removeEventListener('chargingtimechange', updateState);\n        batteryManager.removeEventListener('dischargingtimechange', updateState);\n      }\n    };\n  }, []);\n  return state;\n};\nexport default useBattery;","import isFunction from \"../utils/isFunction\";\nimport { useCallback, useEffect } from 'react';\nvar useBeforeUnload = function useBeforeUnload(enabled, message) {\n  var handler = useCallback(function (event) {\n    if (isFunction(enabled) ? enabled() : enabled) {\n      event.preventDefault();\n      if (message) {\n        event.returnValue = message;\n      }\n      return message;\n    }\n  }, [enabled, message]);\n  useEffect(function () {\n    if (!enabled) {\n      return;\n    }\n    window.addEventListener('beforeunload', handler);\n    return function () {\n      window.removeEventListener('beforeunload', handler);\n    };\n  }, [enabled, handler]);\n};\nexport default useBeforeUnload;","/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\nexport { api as default };\n","import { useEffect } from 'react';\nvar useEffectOnce = function useEffectOnce(effect) {\n  useEffect(effect, []);\n};\nexport default useEffectOnce;","import useEffectOnce from \"../useEffectOnce\";\nvar useMount = function useMount(fn) {\n  useEffectOnce(function () {\n    fn();\n  });\n};\nexport default useMount;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport JSCookie from 'js-cookie';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport useMount from \"../useMount\";\nvar useCookie = function useCookie(cookieKey) {\n  var firstMount = useRef(true);\n  var _useState = useState(JSCookie.get(cookieKey)),\n    _useState2 = _slicedToArray(_useState, 2),\n    value = _useState2[0],\n    setValue = _useState2[1];\n  useEffect(function () {\n    if (!firstMount.current) {\n      setValue(JSCookie.get(cookieKey));\n    }\n  }, [cookieKey]);\n  useMount(function () {\n    firstMount.current = false;\n  });\n  var deleteCallback = useCallback(function () {\n    JSCookie.remove(cookieKey);\n    setValue(undefined);\n  }, [cookieKey]);\n  var updateCallback = useCallback(function (nextValue, options) {\n    JSCookie.set(cookieKey, nextValue, options);\n    setValue(nextValue);\n  }, [cookieKey]);\n  return {\n    value: value,\n    delete: deleteCallback,\n    update: updateCallback\n  };\n};\nexport default useCookie;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { useEffect, useMemo, useRef, useState } from 'react';\nimport { useInterval } from '..';\nimport isNumber from \"../utils/isNumber\";\nvar units = [{\n  name: 'days',\n  num: 86400000\n}, {\n  name: 'hours',\n  num: 3600000\n}, {\n  name: 'minutes',\n  num: 60000\n}, {\n  name: 'seconds',\n  num: 1000\n}, {\n  name: 'milliseconds',\n  num: 1\n}];\nvar getLeftTime = function getLeftTime(targetTime) {\n  return Math.max(targetTime - Date.now(), 0);\n};\nvar formatLeftTime = function formatLeftTime(leftTime) {\n  var remainderTime = leftTime;\n  return units.reduce(function (prev, cur) {\n    prev[cur.name] = Math.floor(remainderTime / cur.num);\n    remainderTime = remainderTime % cur.num;\n    return prev;\n  }, {});\n};\nvar useCountdown = function useCountdown() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if ('leftTime' in params && !isNumber(params.leftTime)) {\n    throw new Error('leftTime has to be a number, but got a ' + _typeof(params.leftTime));\n  }\n  if ('targetTime' in params && !isNumber(params.targetTime)) {\n    throw new Error('targetTime has to be a number, but got a ' + _typeof(params.targetTime));\n  }\n  var ready = useRef(false);\n  var interval = useRef();\n  var targetTime = useMemo(function () {\n    if (isNumber(params.leftTime) && params.leftTime > 0) {\n      return Date.now() + params.leftTime;\n    }\n    return params.targetTime || Date.now();\n  }, [params.targetTime, params.leftTime]);\n  var _useState = useState(function () {\n      return getLeftTime(targetTime);\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    leftTime = _useState2[0],\n    setLeftTime = _useState2[1];\n  var intervalCallback = function intervalCallback() {\n    var leftTime = getLeftTime(targetTime);\n    if (leftTime <= 0) {\n      var _interval$current;\n      ready.current = true;\n      (_interval$current = interval.current) === null || _interval$current === void 0 ? void 0 : _interval$current.clear();\n    }\n    setLeftTime(leftTime);\n  };\n  interval.current = useInterval(intervalCallback, {\n    delay: 1000\n  });\n  useEffect(function () {\n    var _interval$current2, _interval$current3;\n    ready.current = false;\n    intervalCallback();\n    (_interval$current2 = interval.current) === null || _interval$current2 === void 0 ? void 0 : _interval$current2.run();\n    return (_interval$current3 = interval.current) === null || _interval$current3 === void 0 ? void 0 : _interval$current3.clear;\n  }, [targetTime]);\n  var formatedResult = useMemo(function () {\n    return formatLeftTime(leftTime);\n  }, [leftTime]);\n  return {\n    isReady: ready.current,\n    leftTime: leftTime,\n    formatedResult: formatedResult\n  };\n};\nexport default useCountdown;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport { useState } from 'react';\nimport isNumber from \"../utils/isNumber\";\nvar resolveValue = function resolveValue(value, min, max) {\n  var result = value;\n  if (isNumber(min)) {\n    result = Math.max(result, min);\n  }\n  if (isNumber(max)) {\n    result = Math.min(result, max);\n  }\n  return result;\n};\nvar useCounter = function useCounter(initValue, options) {\n  if (!isNumber(initValue)) {\n    throw new Error('initValue has to be a number, but got a ' + _typeof(initValue));\n  }\n  var _useState = useState(resolveValue(initValue, options === null || options === void 0 ? void 0 : options.min, options === null || options === void 0 ? void 0 : options.max)),\n    _useState2 = _slicedToArray(_useState, 2),\n    current = _useState2[0],\n    setCurrent = _useState2[1];\n  var initDelta = options && isNumber(options === null || options === void 0 ? void 0 : options.delta) ? options.delta : 1;\n  var setValue = function setValue(newValue) {\n    setCurrent(resolveValue(newValue, options === null || options === void 0 ? void 0 : options.min, options === null || options === void 0 ? void 0 : options.max));\n  };\n  var inc = function inc(delta) {\n    var actDelta = isNumber(delta) ? delta : initDelta;\n    setValue(current + actDelta);\n  };\n  var dec = function dec(delta) {\n    var actDelta = isNumber(delta) ? delta : initDelta;\n    setValue(current - actDelta);\n  };\n  var set = function set(value) {\n    setValue(value);\n  };\n  var reset = function reset(value) {\n    if (isNumber(value)) {\n      setValue(value);\n    } else {\n      setValue(initValue);\n    }\n  };\n  return [current, {\n    inc: inc,\n    dec: dec,\n    set: set,\n    reset: reset\n  }];\n};\nexport default useCounter;","export default function _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}","export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n  return desc;\n}","export default (function (taregt) {\n  return toString.call(taregt) === '[object Number]' && !Number.isNaN(taregt);\n});","import { decorate, createDefaultSetter } from './private/utils';\nvar defineProperty = Object.defineProperty;\n\n\nfunction handleDescriptor(target, key, descriptor) {\n  var configurable = descriptor.configurable,\n      enumerable = descriptor.enumerable,\n      initializer = descriptor.initializer,\n      value = descriptor.value;\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n\n    get: function get() {\n      // This happens if someone accesses the\n      // property directly on the prototype\n      if (this === target) {\n        return;\n      }\n\n      var ret = initializer ? initializer.call(this) : value;\n\n      defineProperty(this, key, {\n        configurable: configurable,\n        enumerable: enumerable,\n        writable: true,\n        value: ret\n      });\n\n      return ret;\n    },\n\n\n    set: createDefaultSetter(key)\n  };\n}\n\nexport default function lazyInitialize() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;\n\nfunction _initDefineProp(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n}\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport lazyInitialize from '../lazy-initialize';\n\nvar defineProperty = Object.defineProperty,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    getOwnPropertyNames = Object.getOwnPropertyNames,\n    getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\n\nexport function isDescriptor(desc) {\n  if (!desc || !desc.hasOwnProperty) {\n    return false;\n  }\n\n  var keys = ['value', 'initializer', 'get', 'set'];\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    if (desc.hasOwnProperty(keys[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function decorate(handleDescriptor, entryArgs) {\n  if (isDescriptor(entryArgs[entryArgs.length - 1])) {\n    return handleDescriptor.apply(undefined, _toConsumableArray(entryArgs).concat([[]]));\n  } else {\n    return function () {\n      return handleDescriptor.apply(undefined, _toConsumableArray(Array.prototype.slice.call(arguments)).concat([entryArgs]));\n    };\n  }\n}\n\nvar Meta = (_class = function Meta() {\n  _classCallCheck(this, Meta);\n\n  _initDefineProp(this, 'debounceTimeoutIds', _descriptor, this);\n\n  _initDefineProp(this, 'throttleTimeoutIds', _descriptor2, this);\n\n  _initDefineProp(this, 'throttlePreviousTimestamps', _descriptor3, this);\n\n  _initDefineProp(this, 'throttleTrailingArgs', _descriptor4, this);\n\n  _initDefineProp(this, 'profileLastRan', _descriptor5, this);\n}, (_descriptor = _applyDecoratedDescriptor(_class.prototype, 'debounceTimeoutIds', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, 'throttleTimeoutIds', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, 'throttlePreviousTimestamps', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, 'throttleTrailingArgs', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return null;\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, 'profileLastRan', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return null;\n  }\n})), _class);\n\n\nvar META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';\n\nexport function metaFor(obj) {\n  if (obj.hasOwnProperty(META_KEY) === false) {\n    defineProperty(obj, META_KEY, {\n      // Defaults: NOT enumerable, configurable, or writable\n      value: new Meta()\n    });\n  }\n\n  return obj[META_KEY];\n}\n\nexport var getOwnKeys = getOwnPropertySymbols ? function (object) {\n  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n} : getOwnPropertyNames;\n\nexport function getOwnPropertyDescriptors(obj) {\n  var descs = {};\n\n  getOwnKeys(obj).forEach(function (key) {\n    return descs[key] = getOwnPropertyDescriptor(obj, key);\n  });\n\n  return descs;\n}\n\nexport function createDefaultSetter(key) {\n  return function set(newValue) {\n    Object.defineProperty(this, key, {\n      configurable: true,\n      writable: true,\n      // IS enumerable when reassigned by the outside word\n      enumerable: true,\n      value: newValue\n    });\n\n    return newValue;\n  };\n}\n\nexport function bind(fn, context) {\n  if (fn.bind) {\n    return fn.bind(context);\n  } else {\n    return function __autobind__() {\n      return fn.apply(context, arguments);\n    };\n  }\n}\n\nexport var warn = function () {\n  if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) !== 'object' || !console || typeof console.warn !== 'function') {\n    return function () {};\n  } else {\n    return bind(console.warn, console);\n  }\n}();\n\nvar seenDeprecations = {};\nexport function internalDeprecation(msg) {\n  if (seenDeprecations[msg] !== true) {\n    seenDeprecations[msg] = true;\n    warn('DEPRECATION: ' + msg);\n  }\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport { decorate } from './private/utils';\n\nvar GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';\nvar FUNCTION_REGEXP = /^function ([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?(\\([^\\)]*\\))[\\s\\S]+$/;\n\nvar SyntaxErrorReporter = function () {\n  _createClass(SyntaxErrorReporter, [{\n    key: '_getTopic',\n    value: function _getTopic(descriptor) {\n      if (descriptor === undefined) {\n        return null;\n      }\n\n      if ('value' in descriptor) {\n        return descriptor.value;\n      }\n\n      if ('get' in descriptor) {\n        return descriptor.get;\n      }\n\n      if ('set' in descriptor) {\n        return descriptor.set;\n      }\n    }\n  }, {\n    key: '_extractTopicSignature',\n    value: function _extractTopicSignature(topic) {\n      switch (typeof topic === 'undefined' ? 'undefined' : _typeof(topic)) {\n        case 'function':\n          return this._extractFunctionSignature(topic);\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: '_extractFunctionSignature',\n    value: function _extractFunctionSignature(fn) {\n      var _this = this;\n\n      return fn.toString().replace(FUNCTION_REGEXP, function (match) {\n        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;\n        var params = arguments[2];\n        return name + params;\n      });\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      return this.childDescriptor.key;\n    }\n  }, {\n    key: 'parentNotation',\n    get: function get() {\n      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;\n    }\n  }, {\n    key: 'childNotation',\n    get: function get() {\n      return this.childKlass.constructor.name + '#' + this.childPropertySignature;\n    }\n  }, {\n    key: 'parentTopic',\n    get: function get() {\n      return this._getTopic(this.parentDescriptor);\n    }\n  }, {\n    key: 'childTopic',\n    get: function get() {\n      return this._getTopic(this.childDescriptor);\n    }\n  }, {\n    key: 'parentPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.parentTopic);\n    }\n  }, {\n    key: 'childPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.childTopic);\n    }\n  }]);\n\n  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {\n    _classCallCheck(this, SyntaxErrorReporter);\n\n    this.parentKlass = parentKlass;\n    this.childKlass = childKlass;\n    this.parentDescriptor = parentDescriptor;\n    this.childDescriptor = childDescriptor;\n  }\n\n  _createClass(SyntaxErrorReporter, [{\n    key: 'assert',\n    value: function assert(condition) {\n      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (condition !== true) {\n        this.error(GENERIC_FUNCTION_ERROR + msg);\n      }\n    }\n  }, {\n    key: 'error',\n    value: function error(msg) {\n      var _this2 = this;\n\n      msg = msg\n      // Replace lazily, because they actually might not\n      // be available in all cases\n      .replace('{parent}', function (m) {\n        return _this2.parentNotation;\n      }).replace('{child}', function (m) {\n        return _this2.childNotation;\n      });\n      throw new SyntaxError(msg);\n    }\n  }]);\n\n  return SyntaxErrorReporter;\n}();\n\nfunction getDescriptorType(descriptor) {\n  if (descriptor.hasOwnProperty('value')) {\n    return 'data';\n  }\n\n  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {\n    return 'accessor';\n  }\n\n  // If none of them exist, browsers treat it as\n  // a data descriptor with a value of `undefined`\n  return 'data';\n}\n\nfunction checkFunctionSignatures(parent, child, reporter) {\n  reporter.assert(parent.length === child.length);\n}\n\nfunction checkDataDescriptors(parent, child, reporter) {\n  var parentValueType = _typeof(parent.value);\n  var childValueType = _typeof(child.value);\n\n  if (parentValueType === 'undefined' && childValueType === 'undefined') {\n    // class properties can be any expression, which isn't ran until the\n    // the instance is created, so we can't reliably get type information\n    // for them yet (per spec). Perhaps when Babel includes flow-type info\n    // in runtime? Tried regex solutions, but super hacky and only feasible\n    // on primitives, which is confusing for usage...\n    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\\'');\n  }\n\n  if (parentValueType !== childValueType) {\n    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined;\n    // Even though we don't support class properties, this\n    // will still handle more than just functions, just in case.\n    // Shadowing an undefined value is an error if the inherited\n    // value was undefined (usually a class property, not a method)\n    if (isFunctionOverUndefined || parentValueType !== undefined) {\n      reporter.error('value types do not match. {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n    }\n  }\n\n  // Switch, in preparation for supporting more types\n  switch (childValueType) {\n    case 'function':\n      checkFunctionSignatures(parent.value, child.value, reporter);\n      break;\n\n    default:\n      reporter.error('Unexpected error. Please file a bug with: {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n      break;\n  }\n}\n\nfunction checkAccessorDescriptors(parent, child, reporter) {\n  var parentHasGetter = typeof parent.get === 'function';\n  var childHasGetter = typeof child.get === 'function';\n  var parentHasSetter = typeof parent.set === 'function';\n  var childHasSetter = typeof child.set === 'function';\n\n  if (parentHasGetter || childHasGetter) {\n    if (!parentHasGetter && parentHasSetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    if (!childHasGetter && childHasSetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    checkFunctionSignatures(parent.get, child.get, reporter);\n  }\n\n  if (parentHasSetter || childHasSetter) {\n    if (!parentHasSetter && parentHasGetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    if (!childHasSetter && childHasGetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    checkFunctionSignatures(parent.set, child.set, reporter);\n  }\n}\n\nfunction checkDescriptors(parent, child, reporter) {\n  var parentType = getDescriptorType(parent);\n  var childType = getDescriptorType(child);\n\n  if (parentType !== childType) {\n    reporter.error('descriptor types do not match. {parent} is \"' + parentType + '\", {child} is \"' + childType + '\"');\n  }\n\n  switch (childType) {\n    case 'data':\n      checkDataDescriptors(parent, child, reporter);\n      break;\n\n    case 'accessor':\n      checkAccessorDescriptors(parent, child, reporter);\n      break;\n  }\n}\n\nvar suggestionTransforms = [function (key) {\n  return key.toLowerCase();\n}, function (key) {\n  return key.toUpperCase();\n}, function (key) {\n  return key + 's';\n}, function (key) {\n  return key.slice(0, -1);\n}, function (key) {\n  return key.slice(1, key.length);\n}];\n\nfunction findPossibleAlternatives(superKlass, key) {\n  for (var i = 0, l = suggestionTransforms.length; i < l; i++) {\n    var fn = suggestionTransforms[i];\n    var suggestion = fn(key);\n\n    if (suggestion in superKlass) {\n      return suggestion;\n    }\n  }\n\n  return null;\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.key = key;\n  var superKlass = Object.getPrototypeOf(target);\n  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);\n  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);\n\n  if (superDescriptor === undefined) {\n    var suggestedKey = findPossibleAlternatives(superKlass, key);\n    var suggestion = suggestedKey ? '\\n\\n  Did you mean \"' + suggestedKey + '\"?' : '';\n    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);\n  }\n\n  checkDescriptors(superDescriptor, descriptor, reporter);\n\n  return descriptor;\n}\n\nexport default function override() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { decorate, warn } from './private/utils';\n\nvar DEFAULT_MSG = 'This function will be removed in future versions.';\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      msg = _ref2$ === undefined ? DEFAULT_MSG : _ref2$,\n      _ref2$2 = _ref2[1],\n      options = _ref2$2 === undefined ? {} : _ref2$2;\n\n  if (typeof descriptor.value !== 'function') {\n    throw new SyntaxError('Only functions can be marked as deprecated');\n  }\n\n  var methodSignature = target.constructor.name + '#' + key;\n\n  if (options.url) {\n    msg += '\\n\\n    See ' + options.url + ' for more details.\\n\\n';\n  }\n\n  return _extends({}, descriptor, {\n    value: function deprecationWrapper() {\n      warn('DEPRECATION ' + methodSignature + ': ' + msg);\n      return descriptor.value.apply(this, arguments);\n    }\n  });\n}\n\nexport default function deprecate() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { decorate } from './private/utils';\n\nfunction suppressedWarningNoop() {\n  // Warnings are currently suppressed via @suppressWarnings\n}\n\nfunction applyWithoutWarnings(context, fn, args) {\n  if ((typeof console === 'undefined' ? 'undefined' : _typeof(console)) === 'object') {\n    var nativeWarn = console.warn;\n    console.warn = suppressedWarningNoop;\n    var ret = fn.apply(context, args);\n    console.warn = nativeWarn;\n    return ret;\n  } else {\n    return fn.apply(context, args);\n  }\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  return _extends({}, descriptor, {\n    value: function suppressWarningsWrapper() {\n      return applyWithoutWarnings(this, descriptor.value, arguments);\n    }\n  });\n}\n\nexport default function suppressWarnings() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { decorate, internalDeprecation } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return { fn: fn, wrapKey: wrapKey };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}","function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { decorate, createDefaultSetter, getOwnPropertyDescriptors, getOwnKeys, bind } from './private/utils';\nvar defineProperty = Object.defineProperty,\n    getPrototypeOf = Object.getPrototypeOf;\n\n\nvar mapStore = void 0;\n\nfunction getBoundSuper(obj, fn) {\n  if (typeof WeakMap === 'undefined') {\n    throw new Error('Using @autobind on ' + fn.name + '() requires WeakMap support due to its use of super.' + fn.name + '()\\n      See https://github.com/jayphelps/core-decorators.js/issues/20');\n  }\n\n  if (!mapStore) {\n    mapStore = new WeakMap();\n  }\n\n  if (mapStore.has(obj) === false) {\n    mapStore.set(obj, new WeakMap());\n  }\n\n  var superStore = mapStore.get(obj);\n\n  if (superStore.has(fn) === false) {\n    superStore.set(fn, bind(fn, obj));\n  }\n\n  return superStore.get(fn);\n}\n\nfunction autobindClass(klass) {\n  var descs = getOwnPropertyDescriptors(klass.prototype);\n  var keys = getOwnKeys(descs);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    var desc = descs[key];\n\n    if (typeof desc.value !== 'function' || key === 'constructor') {\n      continue;\n    }\n\n    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));\n  }\n}\n\nfunction autobindMethod(target, key, _ref) {\n  var fn = _ref.value,\n      configurable = _ref.configurable,\n      enumerable = _ref.enumerable;\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@autobind can only be used on functions, not: ' + fn);\n  }\n\n  var constructor = target.constructor;\n\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n\n    get: function get() {\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on the prototype on which it is\n      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)\n      if (this === target) {\n        return fn;\n      }\n\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on a prototype but it was found\n      // up the chain, not defined directly on it\n      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype\n      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {\n        return fn;\n      }\n\n      // Autobound method calling super.sameMethod() which is also autobound and so on.\n      if (this.constructor !== constructor && key in this.constructor.prototype) {\n        return getBoundSuper(this, fn);\n      }\n\n      var boundFn = bind(fn, this);\n\n      defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        // NOT enumerable when it's a bound method\n        enumerable: false,\n        value: boundFn\n      });\n\n      return boundFn;\n    },\n\n    set: createDefaultSetter(key)\n  };\n}\n\nfunction handle(args) {\n  if (args.length === 1) {\n    return autobindClass.apply(undefined, _toConsumableArray(args));\n  } else {\n    return autobindMethod.apply(undefined, _toConsumableArray(args));\n  }\n}\n\nexport default function autobind() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 0) {\n    return function () {\n      return handle(arguments);\n    };\n  } else {\n    return handle(args);\n  }\n}","import { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nexport default function readonly() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","import { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.enumerable = true;\n  return descriptor;\n}\n\nexport default function enumerable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","import { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n\nexport default function nonenumerable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","import { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.configurable = false;\n  return descriptor;\n}\n\nexport default function nonconfigurable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { decorate, metaFor, internalDeprecation } from './private/utils';\n\nvar DEFAULT_TIMEOUT = 300;\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      wait = _ref2$ === undefined ? DEFAULT_TIMEOUT : _ref2$,\n      _ref2$2 = _ref2[1],\n      immediate = _ref2$2 === undefined ? false : _ref2$2;\n\n  var callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be debounced');\n  }\n\n  return _extends({}, descriptor, {\n    value: function value() {\n      var _this = this;\n\n      var _metaFor = metaFor(this),\n          debounceTimeoutIds = _metaFor.debounceTimeoutIds;\n\n      var timeout = debounceTimeoutIds[key];\n      var callNow = immediate && !timeout;\n      var args = arguments;\n\n      clearTimeout(timeout);\n\n      debounceTimeoutIds[key] = setTimeout(function () {\n        delete debounceTimeoutIds[key];\n        if (!immediate) {\n          callback.apply(_this, args);\n        }\n      }, wait);\n\n      if (callNow) {\n        callback.apply(this, args);\n      }\n    }\n  });\n}\n\nexport default function debounce() {\n  internalDeprecation('@debounce is deprecated and will be removed shortly. Use @debounce from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { decorate, metaFor, internalDeprecation } from './private/utils';\n\nvar DEFAULT_TIMEOUT = 300;\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      wait = _ref2$ === undefined ? DEFAULT_TIMEOUT : _ref2$,\n      _ref2$2 = _ref2[1],\n      options = _ref2$2 === undefined ? {} : _ref2$2;\n\n  var callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be throttled');\n  }\n\n  if (options.leading !== false) {\n    options.leading = true;\n  }\n\n  if (options.trailing !== false) {\n    options.trailing = true;\n  }\n\n  return _extends({}, descriptor, {\n    value: function value() {\n      var _this = this;\n\n      var meta = metaFor(this);\n      var throttleTimeoutIds = meta.throttleTimeoutIds,\n          throttlePreviousTimestamps = meta.throttlePreviousTimestamps;\n\n      var timeout = throttleTimeoutIds[key];\n      // last execute timestamp\n      var previous = throttlePreviousTimestamps[key] || 0;\n      var now = Date.now();\n\n      if (options.trailing) {\n        meta.throttleTrailingArgs = arguments;\n      }\n\n      // if first be called and disable the execution on the leading edge\n      // set last execute timestamp to now\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n\n      var remaining = wait - (now - previous);\n\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        delete throttleTimeoutIds[key];\n        throttlePreviousTimestamps[key] = now;\n        callback.apply(this, arguments);\n      } else if (!timeout && options.trailing) {\n        throttleTimeoutIds[key] = setTimeout(function () {\n          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();\n          delete throttleTimeoutIds[key];\n          callback.apply(_this, meta.throttleTrailingArgs);\n          // don't leak memory!\n          meta.throttleTrailingArgs = null;\n        }, remaining);\n      }\n    }\n  });\n}\n\nexport default function throttle() {\n  internalDeprecation('@throttle is deprecated and will be removed shortly. Use @throttle from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\nimport { decorate as _decorate, createDefaultSetter } from './private/utils';\nvar defineProperty = Object.defineProperty;\n\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _toArray(_ref),\n      decorator = _ref2[0],\n      args = _ref2.slice(1);\n\n  var configurable = descriptor.configurable,\n      enumerable = descriptor.enumerable,\n      writable = descriptor.writable;\n\n  var originalGet = descriptor.get;\n  var originalSet = descriptor.set;\n  var originalValue = descriptor.value;\n  var isGetter = !!originalGet;\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n    get: function get() {\n      var fn = isGetter ? originalGet.call(this) : originalValue;\n      var value = decorator.call.apply(decorator, [this, fn].concat(_toConsumableArray(args)));\n\n      if (isGetter) {\n        return value;\n      } else {\n        var desc = {\n          configurable: configurable,\n          enumerable: enumerable\n        };\n\n        desc.value = value;\n        desc.writable = writable;\n\n        defineProperty(this, key, desc);\n\n        return value;\n      }\n    },\n\n    set: isGetter ? originalSet : createDefaultSetter()\n  };\n}\n\nexport default function decorate() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _decorate(handleDescriptor, args);\n}","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { getOwnPropertyDescriptors, getOwnKeys, internalDeprecation } from './private/utils';\n\nvar defineProperty = Object.defineProperty,\n    getPrototypeOf = Object.getPrototypeOf;\n\n\nfunction buggySymbol(symbol) {\n  return Object.prototype.toString.call(symbol) === '[object Symbol]' && (typeof symbol === 'undefined' ? 'undefined' : _typeof(symbol)) === 'object';\n}\n\nfunction hasProperty(prop, obj) {\n  // We have to traverse manually prototypes' chain for polyfilled ES6 Symbols\n  // like \"in\" operator does.\n  // I.e.: Babel 5 Symbol polyfill stores every created symbol in Object.prototype.\n  // That's why we cannot use construction like \"prop in obj\" to check, if needed\n  // prop actually exists in given object/prototypes' chain.\n  if (buggySymbol(prop)) {\n    do {\n      if (obj === Object.prototype) {\n        // Polyfill assigns undefined as value for stored symbol key.\n        // We can assume in this special case if there is nothing assigned it doesn't exist.\n        return typeof obj[prop] !== 'undefined';\n      }\n      if (obj.hasOwnProperty(prop)) {\n        return true;\n      }\n    } while (obj = getPrototypeOf(obj));\n    return false;\n  } else {\n    return prop in obj;\n  }\n}\n\nfunction handleClass(target, mixins) {\n  if (!mixins.length) {\n    throw new SyntaxError('@mixin() class ' + target.name + ' requires at least one mixin as an argument');\n  }\n\n  for (var i = 0, l = mixins.length; i < l; i++) {\n    var descs = getOwnPropertyDescriptors(mixins[i]);\n    var keys = getOwnKeys(descs);\n\n    for (var j = 0, k = keys.length; j < k; j++) {\n      var key = keys[j];\n\n      if (!hasProperty(key, target.prototype)) {\n        defineProperty(target.prototype, key, descs[key]);\n      }\n    }\n  }\n}\n\nexport default function mixin() {\n  for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {\n    mixins[_key] = arguments[_key];\n  }\n\n  internalDeprecation('@mixin is deprecated and will be removed shortly. Use @mixin from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  if (typeof mixins[0] === 'function') {\n    return handleClass(mixins[0], []);\n  } else {\n    return function (target) {\n      return handleClass(target, mixins);\n    };\n  }\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { decorate } from './private/utils';\n\nvar labels = {};\n\n// Exported for mocking in tests\nexport var defaultConsole = {\n  time: console.time ? console.time.bind(console) : function (label) {\n    labels[label] = new Date();\n  },\n  timeEnd: console.timeEnd ? console.timeEnd.bind(console) : function (label) {\n    var timeNow = new Date();\n    var timeTaken = timeNow - labels[label];\n    delete labels[label];\n    console.log(label + ': ' + timeTaken + 'ms');\n  }\n};\n\nvar count = 0;\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      prefix = _ref2$ === undefined ? null : _ref2$,\n      _ref2$2 = _ref2[1],\n      console = _ref2$2 === undefined ? defaultConsole : _ref2$2;\n\n  var fn = descriptor.value;\n\n  if (prefix === null) {\n    prefix = target.constructor.name + '.' + key;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@time can only be used on functions, not: ' + fn);\n  }\n\n  return _extends({}, descriptor, {\n    value: function value() {\n      var label = prefix + '-' + count;\n      count++;\n      console.time(label);\n\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        console.timeEnd(label);\n      }\n    }\n  });\n}\n\nexport default function time() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { decorate } from './private/utils';\nvar getPrototypeOf = Object.getPrototypeOf,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\nfunction handleDescriptor(target, key, descriptor) {\n  var superKlass = getPrototypeOf(target);\n  var superDesc = getOwnPropertyDescriptor(superKlass, key);\n\n  return _extends({}, superDesc, {\n    value: descriptor.value,\n    initializer: descriptor.initializer,\n    get: descriptor.get || superDesc.get,\n    set: descriptor.set || superDesc.set\n  });\n}\n\nexport default function extendDescriptor() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nimport { decorate, metaFor, warn, bind } from './private/utils';\n\nvar oc = console;\n\n// Exported for mocking in tests\nexport var defaultConsole = {\n  profile: console.profile ? bind(console.profile, console) : function () {},\n  profileEnd: console.profileEnd ? bind(console.profileEnd, console) : function () {},\n  warn: warn\n};\n\nfunction handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n      _ref2$ = _ref2[0],\n      prefix = _ref2$ === undefined ? null : _ref2$,\n      _ref2$2 = _ref2[1],\n      onceThrottleOrFunction = _ref2$2 === undefined ? false : _ref2$2,\n      _ref2$3 = _ref2[2],\n      console = _ref2$3 === undefined ? defaultConsole : _ref2$3;\n\n  if (!profile.__enabled) {\n    if (!profile.__warned) {\n      console.warn('console.profile is not supported. All @profile decorators are disabled.');\n      profile.__warned = true;\n    }\n    return descriptor;\n  }\n\n  var fn = descriptor.value;\n\n  if (prefix === null) {\n    prefix = target.constructor.name + '.' + key;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@profile can only be used on functions, not: ' + fn);\n  }\n\n  return _extends({}, descriptor, {\n    value: function value() {\n      var now = Date.now();\n      var meta = metaFor(this);\n      if (onceThrottleOrFunction === true && !meta.profileLastRan || onceThrottleOrFunction === false || typeof onceThrottleOrFunction === 'number' && now - meta.profileLastRan > onceThrottleOrFunction || typeof onceThrottleOrFunction === 'function' && onceThrottleOrFunction.apply(this, arguments)) {\n        console.profile(prefix);\n        meta.profileLastRan = now;\n      }\n\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        console.profileEnd(prefix);\n      }\n    }\n  });\n}\n\nexport default function profile() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(handleDescriptor, args);\n}\n\n// Only Chrome, Firefox, and Edge support profile.\n// Exposing properties for testing.\nprofile.__enabled = !!console.profile;\nprofile.__warned = false;","var defineProperty = Object.defineProperty,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\nexport default function applyDecorators(Class, props) {\n  var prototype = Class.prototype;\n\n\n  for (var key in props) {\n    var decorators = props[key];\n\n    for (var i = 0, l = decorators.length; i < l; i++) {\n      var decorator = decorators[i];\n\n      defineProperty(prototype, key, decorator(prototype, key, getOwnPropertyDescriptor(prototype, key)));\n    }\n  }\n\n  return Class;\n}","/**\n * core-decorators.js\n * (c) 2017 Jay Phelps and contributors\n * MIT Licensed\n * https://github.com/jayphelps/core-decorators.js\n * @license\n */\nexport { default as override } from './override';\nexport { default as deprecate, default as deprecated } from './deprecate';\nexport { default as suppressWarnings } from './suppress-warnings';\nexport { default as memoize } from './memoize';\nexport { default as autobind } from './autobind';\nexport { default as readonly } from './readonly';\nexport { default as enumerable } from './enumerable';\nexport { default as nonenumerable } from './nonenumerable';\nexport { default as nonconfigurable } from './nonconfigurable';\nexport { default as debounce } from './debounce';\nexport { default as throttle } from './throttle';\nexport { default as decorate } from './decorate';\nexport { default as mixin, default as mixins } from './mixin';\nexport { default as lazyInitialize } from './lazy-initialize';\nexport { default as time } from './time';\nexport { default as extendDescriptor } from './extendDescriptor';\nexport { default as profile } from './profile';\n\n// Helper to apply decorators to a class without transpiler support\nexport { default as applyDecorators } from './applyDecorators';","var isBrowser = function isBrowser() {\n  return typeof window !== 'undefined';\n};\nexport default isBrowser;","export var MsgType = /*#__PURE__*/function (MsgType) {\n  MsgType[MsgType[\"Create\"] = 0] = \"Create\";\n  MsgType[MsgType[\"Execute\"] = 1] = \"Execute\";\n  MsgType[MsgType[\"Clear\"] = 2] = \"Clear\";\n  return MsgType;\n}({});","import isBrowser from \"../isBrowser\";\nimport { MsgType } from \"./types\";\nif (isBrowser()) {\n  var webWorker = self;\n  webWorker.addEventListener('message', function (message) {\n    var data = message.data;\n    switch (data.type) {\n      case MsgType.Create:\n        {\n          var $timer = setTimeout(function () {\n            webWorker.postMessage({\n              taskId: data.taskId,\n              type: MsgType.Execute\n            });\n            clearTimeout($timer);\n          }, data.wait);\n          webWorker.postMessage({\n            taskId: data.taskId,\n            timer: $timer,\n            type: MsgType.Create\n          });\n          break;\n        }\n      case MsgType.Clear:\n        {\n          clearTimeout(data.timerId);\n          webWorker.postMessage({\n            taskId: data.taskId,\n            type: MsgType.Clear\n          });\n          break;\n        }\n    }\n  });\n}\nexport default null;","import _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\nvar _class, _class2, _descriptor;\nimport isNumber from \"../isNumber\";\nimport { autobind, readonly } from 'core-decorators';\nimport TimerWorker from \"./timer.worker\";\nimport { MsgType } from \"./types\";\nvar taskSeed = 1;\nvar createTask = function createTask() {\n  return {\n    taskId: taskSeed++\n  };\n};\nvar createMsg = function createMsg(type, taskId) {\n  return {\n    type: type,\n    taskId: taskId\n  };\n};\nvar WorkerTimer = autobind(_class = (_class2 = /*#__PURE__*/function () {\n  function WorkerTimer() {\n    _classCallCheck(this, WorkerTimer);\n    _defineProperty(this, \"taskMap\", new Map());\n    _initializerDefineProperty(this, \"worker\", _descriptor, this);\n    this.init();\n  }\n  _createClass(WorkerTimer, [{\n    key: \"init\",\n    value: function init() {\n      this.onMessage();\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(callback) {\n      var _this = this;\n      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var newTask = createTask();\n      newTask.handler = callback;\n      this.taskMap.set(newTask.taskId, newTask);\n      var msg = createMsg(MsgType.Create, newTask.taskId);\n      msg.wait = wait;\n      this.worker.postMessage(msg);\n      return function () {\n        _this.clear(newTask.taskId);\n      };\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(id) {\n      if (isNumber(id) && this.taskMap.has(id)) {\n        var _this$taskMap$get;\n        var msg = createMsg(MsgType.Create, id);\n        msg.timer = (_this$taskMap$get = this.taskMap.get(id)) === null || _this$taskMap$get === void 0 ? void 0 : _this$taskMap$get.timer;\n        this.worker.postMessage(msg);\n      }\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage() {\n      var _this2 = this;\n      this.worker.onmessage = function (event) {\n        var data = event.data;\n        switch (data.type) {\n          case MsgType.Create:\n            {\n              var task = _this2.taskMap.get(data.taskId);\n              if (!task) {\n                return;\n              }\n              task.timer = data.timer;\n              _this2.taskMap.set(data.taskId, task);\n              break;\n            }\n          case MsgType.Execute:\n            {\n              var _task$handler;\n              var _task = _this2.taskMap.get(data.taskId);\n              if (!_task) {\n                return;\n              }\n              (_task$handler = _task.handler) === null || _task$handler === void 0 ? void 0 : _task$handler.call(_task);\n              _this2.taskMap.delete(_task.taskId);\n              break;\n            }\n          case MsgType.Clear:\n            {\n              _this2.taskMap.delete(data.taskId);\n              break;\n            }\n        }\n      };\n    }\n  }]);\n  return WorkerTimer;\n}(), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"worker\", [readonly], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return new TimerWorker('');\n  }\n})), _class2)) || _class;\nexport default WorkerTimer;","import WorkerTimer from '.';\nvar install;\nexport var getWorkerTimer = function getWorkerTimer() {\n  if (install) {\n    return install;\n  }\n  return install = new WorkerTimer();\n};","import { useRef } from 'react';\nvar useLatest = function useLatest(value) {\n  var ref = useRef(value);\n  ref.current = value;\n  return ref;\n};\nexport default useLatest;","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport isFunction from \"../utils/isFunction\";\nimport { getWorkerTimer } from \"../utils/work-timer/helper\";\nimport { useCallback, useEffect, useRef } from 'react';\nimport useLatest from \"../useLatest\";\nvar clearTimer = function clearTimer() {\n  var useWorker = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var timer = arguments.length > 1 ? arguments[1] : undefined;\n  if (useWorker) {\n    timer === null || timer === void 0 ? void 0 : timer();\n  }\n  clearTimeout(timer);\n};\nvar useTimeoutFn = function useTimeoutFn(fn, options) {\n  if (!isFunction(fn)) {\n    throw new Error('fn has to be a function, but got a ' + _typeof(fn));\n  }\n  var timeoutRef = useRef();\n  var readyRef = useRef(null);\n  var fnRef = useLatest(fn);\n  var delay = (options === null || options === void 0 ? void 0 : options.delay) || 0;\n  var reset = useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    readyRef.current = false;\n    if (timeoutRef.current) {\n      clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n    }\n    timeoutRef.current = (options !== null && options !== void 0 && options.useWorker ? getWorkerTimer().setTimeout : setTimeout)(function () {\n      var _fnRef$current;\n      readyRef.current = true;\n      (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));\n      if (timeoutRef.current) {\n        clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n      }\n    }, delay);\n  }, [delay]);\n  var isReady = useCallback(function () {\n    return readyRef.current;\n  }, []);\n  var cancel = useCallback(function () {\n    readyRef.current = null;\n    if (timeoutRef.current) {\n      clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n    }\n  }, []);\n  useEffect(function () {\n    if (options !== null && options !== void 0 && options.immediate) {\n      reset();\n      return cancel;\n    }\n  }, []);\n  return {\n    run: reset,\n    isReady: isReady,\n    reset: reset,\n    cancel: cancel\n  };\n};\nexport default useTimeoutFn;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport useTimeoutFn from \"../useTimeoutFn\";\nvar useDebounce = function useDebounce(value) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var _useState = useState(value),\n    _useState2 = _slicedToArray(_useState, 2),\n    debounced = _useState2[0],\n    setDebounced = _useState2[1];\n  var _useTimeoutFn = useTimeoutFn(function () {\n      setDebounced(value);\n    }, {\n      delay: wait\n    }),\n    run = _useTimeoutFn.run;\n  useEffect(function () {\n    run();\n  }, [value]);\n  return debounced;\n};\nexport default useDebounce;","import useTimeoutFn from \"../useTimeoutFn\";\nvar useDebounceFn = function useDebounceFn(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return useTimeoutFn(fn, {\n    delay: wait\n  });\n};\nexport default useDebounceFn;","import isBrowser from \"../utils/isBrowser\";\nimport { useEffect } from 'react';\nvar defaultTarget = isBrowser() ? window : null;\nvar useEvent = function useEvent(eventName, handler) {\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTarget;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  useEffect(function () {\n    if (!handler) {\n      return;\n    }\n    if (!target) {\n      return;\n    }\n    target.addEventListener(eventName, handler, options);\n    return function () {\n      target.removeEventListener(eventName, handler, options);\n    };\n  }, []);\n};\nexport default useEvent;","import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _excluded = [\"eventNames\"];\nimport { useEffect, useRef } from 'react';\nvar defaultEvents = ['click'];\nvar useEventAway = function useEventAway(ref, callback, options) {\n  var callbackRef = useRef(callback);\n  useEffect(function () {\n    callbackRef.current = callback;\n  }, [callback]);\n  useEffect(function () {\n    var _ref = options || {},\n      _ref$eventNames = _ref.eventNames,\n      eventNames = _ref$eventNames === void 0 ? defaultEvents : _ref$eventNames,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    var handler = function handler(event) {\n      if (ref.current && !ref.current.contains(event.target)) {\n        callbackRef.current(event);\n      }\n    };\n    eventNames.forEach(function (eventName) {\n      return document.addEventListener(eventName, handler, rest);\n    });\n    return function () {\n      eventNames.forEach(function (eventName) {\n        return document.removeEventListener(eventName, handler, rest);\n      });\n    };\n  }, [ref, options]);\n};\nexport default useEventAway;","import { useEffect } from 'react';\nvar useFavicon = function useFavicon(href) {\n  useEffect(function () {\n    var link = document.querySelector(\"link[rel*='icon']\") || document.createElement('link');\n    link.type = 'image/x-icon';\n    link.rel = 'shortcut icon';\n    link.href = href;\n    document.getElementsByTagName('head')[0].appendChild(link);\n  }, [href]);\n};\nexport default useFavicon;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useEffect, useState } from 'react';\nvar useHash = function useHash() {\n  var _useState = useState(function () {\n      return window.location.hash;\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    hash = _useState2[0],\n    setHash = _useState2[1];\n  useEffect(function () {\n    var callback = function callback() {\n      setHash(window.location.hash);\n    };\n    window.addEventListener('hashchange', callback);\n    return function () {\n      window.removeEventListener('hashchange', callback);\n    };\n  }, []);\n  var write = useCallback(function (newHash) {\n    if (newHash !== hash) {\n      window.location.hash = newHash;\n    }\n  }, [hash]);\n  return [hash, write];\n};\nexport default useHash;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nvar hiddenPropName = function hiddenPropName(document) {\n  if (typeof document.hidden !== 'undefined') {\n    return 'hidden';\n  } else if (typeof document.msHidden !== 'undefined') {\n    return 'msHidden';\n  } else if (typeof document.webkitHidden !== 'undefined') {\n    return 'webkitHidden';\n  }\n  return 'hidden';\n};\nvar getHidden = function getHidden() {\n  return document[hiddenPropName(document)];\n};\nvar useHidden = function useHidden() {\n  var _useState = useState(getHidden),\n    _useState2 = _slicedToArray(_useState, 2),\n    hidden = _useState2[0],\n    setHidden = _useState2[1];\n  useEffect(function () {\n    var callback = function callback() {\n      setHidden(getHidden());\n    };\n    document.addEventListener('visibilitychange', callback);\n    return function () {\n      document.removeEventListener('visibilitychange', callback);\n    };\n  }, []);\n  return hidden;\n};\nexport default useHidden;","import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar Action = /*#__PURE__*/function (Action) {\n  Action[\"Pop\"] = \"POP\";\n  Action[\"Push\"] = \"PUSH\";\n  Action[\"Replace\"] = \"REPLACE\";\n  return Action;\n}(Action || {});\nvar parsePath = function parsePath(path) {\n  var parsedPath = {};\n  if (path) {\n    var hashIndex = path.indexOf('#');\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substring(hashIndex);\n      path = path.substring(0, hashIndex);\n    }\n    var searchIndex = path.indexOf('?');\n    if (searchIndex >= 0) {\n      parsedPath.hash = path.substring(searchIndex);\n      path = path.substring(0, searchIndex);\n    }\n    parsedPath.pathname = path;\n  }\n  return parsedPath;\n};\nvar createLocation = function createLocation(current, to, state) {\n  return _objectSpread(_objectSpread({\n    pathname: typeof current === 'string' ? current : current.pathname,\n    hash: '',\n    search: ''\n  }, typeof to === 'string' ? parsePath(to) : to), {}, {\n    state: state\n  });\n};\nexport var createHistory = function createHistory() {\n  var listener = null;\n  var action = Action.Pop;\n  var globalHistory = window.history;\n  var history = {\n    get location() {\n      var _window$location = window.location,\n        pathname = _window$location.pathname,\n        hash = _window$location.hash,\n        search = _window$location.search;\n      return createLocation('', {\n        pathname: pathname,\n        hash: hash,\n        search: search\n      });\n    },\n    listen: function listen(fn) {\n      var handlePop = function handlePop() {\n        var _listener;\n        var action = Action.Pop;\n        (_listener = listener) === null || _listener === void 0 ? void 0 : _listener({\n          action: action,\n          location: history.location\n        });\n      };\n      window.addEventListener('popstate', handlePop);\n      listener = fn;\n      return function () {\n        window.removeEventListener('popstate', handlePop);\n        listener = null;\n      };\n    },\n    replace: function replace(to, state) {\n      var _listener2;\n      action = Action.Push;\n      var location = createLocation(history.location, to, state);\n      var url = history.createHref(location);\n      globalHistory.pushState(state, '', url);\n      (_listener2 = listener) === null || _listener2 === void 0 ? void 0 : _listener2({\n        action: action,\n        location: history.location\n      });\n    },\n    push: function push(to, state) {\n      var _listener3;\n      action = Action.Push;\n      var location = createLocation(history.location, to, state);\n      var url = history.createHref(location);\n      globalHistory.pushState(state, '', url);\n      (_listener3 = listener) === null || _listener3 === void 0 ? void 0 : _listener3({\n        action: action,\n        location: history.location\n      });\n    },\n    createHref: function createHref(to) {\n      if (typeof to === 'string') {\n        return to;\n      }\n      var pathname = to.pathname,\n        search = to.search,\n        hash = to.hash;\n      var path = pathname;\n      if (search && search !== '') {\n        path += search.charAt(0) === '?' ? search : '?' + search;\n      }\n      if (hash && hash !== '#') {\n        path += hash.charAt(0) === '#' ? hash : '#' + hash;\n      }\n      return path;\n    },\n    go: function go(delta) {\n      globalHistory.go(delta);\n    }\n  };\n  return history;\n};","import { createHistory } from \"../utils/history\";\nimport { useMemo } from 'react';\nvar history;\nvar useHistory = function useHistory() {\n  return useMemo(function () {\n    if (history) {\n      return history;\n    }\n    return history = Object.freeze(createHistory());\n  }, []);\n};\nexport default useHistory;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport isFunction from \"../utils/isFunction\";\nimport { useEffect, useState } from 'react';\nvar useIntersection = function useIntersection(ref, options) {\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    observerEntry = _useState2[0],\n    setObserverEntry = _useState2[1];\n  useEffect(function () {\n    if (ref.current && isFunction(IntersectionObserver)) {\n      var handler = function handler(entries) {\n        setObserverEntry(entries[0]);\n      };\n      var observer = new IntersectionObserver(handler, options);\n      observer.observe(ref.current);\n      return function () {\n        setObserverEntry(null);\n        observer.disconnect();\n      };\n    }\n  }, [ref.current, options === null || options === void 0 ? void 0 : options.root, options === null || options === void 0 ? void 0 : options.rootMargin, options === null || options === void 0 ? void 0 : options.threshold]);\n  return observerEntry;\n};\nexport default useIntersection;","import { useCallback, useEffect, useRef } from 'react';\nimport useLatest from \"../useLatest\";\nvar useInterval = function useInterval(fn, options) {\n  var callback = useLatest(fn);\n  var interval = useRef();\n  var run = useCallback(function () {\n    if (interval.current) {\n      clearInterval(interval.current);\n    }\n    interval.current = setInterval(function () {\n      var _callback$current;\n      (_callback$current = callback.current) === null || _callback$current === void 0 ? void 0 : _callback$current.call(callback);\n    }, (options === null || options === void 0 ? void 0 : options.delay) || 0);\n  }, []);\n  var clear = useCallback(function () {\n    if (interval.current) {\n      clearInterval(interval.current);\n    }\n  }, []);\n  useEffect(function () {\n    if (options !== null && options !== void 0 && options.immediate) {\n      run();\n    }\n  }, []);\n  return {\n    run: run,\n    clear: clear,\n    reset: run\n  };\n};\nexport default useInterval;","import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport useHistory from \"../useHistory\";\nimport { useEffect, useState } from 'react';\nvar useLocation = function useLocation() {\n  var history = useHistory();\n  var _useState = useState(function () {\n      return _objectSpread({}, history.location);\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    location = _useState2[0],\n    setLocation = _useState2[1];\n  useEffect(function () {\n    var cancel = history.listen(function (_ref) {\n      var location = _ref.location;\n      setLocation(location);\n    });\n    return function () {\n      cancel();\n    };\n  }, []);\n  return location;\n};\nexport default useLocation;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport isNumber from \"../utils/isNumber\";\nimport { useMemo, useRef } from 'react';\nvar defaultMaxSize = 10;\nvar useLRU = function useLRU() {\n  var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMaxSize;\n  if (!isNumber(maxSize)) {\n    throw new Error('maxSize has to be a number, but got a ' + _typeof(maxSize));\n  }\n\n  // const [set, setCache] = useState<Map<K, V>>(new Map());\n\n  var cache = useRef(new Map());\n  var utils = useMemo(function () {\n    return {\n      maxSize: maxSize,\n      set: function set(key, value) {\n        if (cache.current.has(key)) {\n          cache.current.delete(key);\n        }\n        if (cache.current.size >= maxSize) {\n          var needDelKey = cache.current.keys().next().value;\n          cache.current.delete(needDelKey);\n        }\n        cache.current.set(key, value);\n      }\n    };\n  }, [maxSize]);\n  return _objectSpread({\n    has: function has(key) {\n      return cache.current.has(key);\n    },\n    peek: function peek(key) {\n      return cache.current.get(key);\n    },\n    get: function get(key) {\n      if (cache.current.has(key)) {\n        var _value = cache.current.get(key);\n        cache.current.delete(key);\n        cache.current.set(key, _value);\n        return _value;\n      }\n      return undefined;\n    },\n    delete: function _delete(key) {\n      return cache.current.delete(key);\n    },\n    clear: function clear() {\n      return cache.current.clear();\n    },\n    keys: function keys() {\n      return Array.from(cache.current.keys());\n    },\n    values: function values() {\n      return Array.from(cache.current.values());\n    },\n    entries: function entries() {\n      return Array.from(cache.current.entries());\n    },\n    pop: function pop() {\n      if (cache.current.size) {\n        var _cache$current$entrie = _slicedToArray(cache.current.entries().next().value, 2),\n          _key = _cache$current$entrie[0],\n          _value2 = _cache$current$entrie[1];\n        cache.current.delete(_key);\n        return _value2;\n      }\n      return undefined;\n    }\n  }, utils);\n};\nexport default useLRU;","import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useMemo, useState } from 'react';\nvar useMap = function useMap(initValue) {\n  var _useState = useState(new Map(initValue)),\n    _useState2 = _slicedToArray(_useState, 2),\n    map = _useState2[0],\n    setMap = _useState2[1];\n  var actions = useMemo(function () {\n    return {\n      set: function set(key, value) {\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          newMap.set(key, value);\n          return newMap;\n        });\n      },\n      delete: function _delete(key) {\n        var result = false;\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          result = newMap.delete(key);\n          return newMap;\n        });\n        return result;\n      },\n      clear: function clear() {\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          newMap.clear();\n          return newMap;\n        });\n      },\n      setAll: function setAll(newValue) {\n        return setMap(new Map(newValue));\n      },\n      reset: function reset() {\n        return setMap(new Map(initValue));\n      }\n    };\n  }, [setMap]);\n  var utils = _objectSpread({\n    has: useCallback(function (key) {\n      return map.has(key);\n    }, [map]),\n    get: useCallback(function (key) {\n      return map.get(key);\n    }, [map])\n  }, actions);\n  return [map, utils];\n};\nexport default useMap;","import { useCallback, useMemo, useRef } from 'react';\nvar useMemoizedFn = function useMemoizedFn(fn) {\n  var ref = useRef(fn);\n  ref.current = useMemo(function () {\n    return fn;\n  }, [fn]);\n  return useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current.apply(this, args);\n  }, []);\n};\nexport default useMemoizedFn;","import useLatest from \"../useLatest\";\nimport { useEffect } from 'react';\nvar useMessage = function useMessage(listener) {\n  var _callback = useLatest(listener);\n  useEffect(function () {\n    var _listener = function _listener(message) {\n      _callback.current(message);\n    };\n    window.addEventListener('message', _listener, false);\n    return function () {\n      window.removeEventListener('message', _listener, false);\n    };\n  });\n};\nexport default useMessage;","import { useCallback, useEffect, useRef } from 'react';\nvar useMountedState = function useMountedState() {\n  var ref = useRef(false);\n  useEffect(function () {\n    ref.current = true;\n  }, []);\n  return useCallback(function () {\n    return ref.current;\n  }, []);\n};\nexport default useMountedState;","export default Object.prototype.toString;","import toString from \"./toString\";\nexport default (function (target) {\n  return toString.call(target) === '[object NetworkInformation]';\n});","import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\nimport isNetworkInformation from \"../utils/isNetworkInformation\";\nvar getConnectionInfo = function getConnectionInfo() {\n  var nav = window.navigator;\n  var con = nav.connection || nav.webkitConnection || nav.mozConnection;\n  if (!isNetworkInformation(con)) {\n    return undefined;\n  }\n  return {\n    effectiveType: con === null || con === void 0 ? void 0 : con.effectiveType,\n    downlink: con === null || con === void 0 ? void 0 : con.downlink,\n    downlinkMax: con === null || con === void 0 ? void 0 : con.downlinkMax,\n    rtt: con === null || con === void 0 ? void 0 : con.rtt,\n    saveData: con === null || con === void 0 ? void 0 : con.saveData,\n    type: con === null || con === void 0 ? void 0 : con.type\n  };\n};\nvar useNetwork = function useNetwork() {\n  var _useState = useState(_objectSpread(_objectSpread({}, getConnectionInfo()), {}, {\n      online: window.navigator.onLine\n    })),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useEffect(function () {\n    var changeOnlineState = function changeOnlineState(online) {\n      setState(function () {\n        return _objectSpread({\n          online: online\n        }, getConnectionInfo());\n      });\n    };\n    var onlineHandler = function onlineHandler() {\n      changeOnlineState(true);\n    };\n    var offlineHandler = function offlineHandler() {\n      changeOnlineState(false);\n    };\n    var changeHandler = function changeHandler() {\n      changeOnlineState(window.navigator.onLine);\n    };\n    window.addEventListener('online', onlineHandler);\n    window.addEventListener('offline', offlineHandler);\n    window.addEventListener('change', changeHandler);\n    changeHandler();\n    return function () {\n      window.removeEventListener('online', onlineHandler);\n      window.removeEventListener('offline', offlineHandler);\n      window.removeEventListener('change', changeHandler);\n    };\n  }, []);\n  return state;\n};\nexport default useNetwork;","import { useMemo } from 'react';\nvar usePlatform = function usePlatform() {\n  var utils = useMemo(function () {\n    var isSafari = function isSafari() {\n      return /Safari/i.test(navigator.userAgent);\n    };\n    // ios\n    var isIOS = function isIOS() {\n      return /iPhone|iPad|iPod/i.test(navigator.userAgent);\n    };\n    // ipados\n    var isIPadOS = function isIPadOS() {\n      return /iPad/i.test(navigator.userAgent) || /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1;\n    };\n    // android\n    var isAndroid = function isAndroid() {\n      return navigator.userAgent.indexOf('Android') > -1 || navigator.userAgent.indexOf('Adr') > -1;\n    };\n    var isMobile = function isMobile() {\n      if (isIPadOS()) {\n        return true;\n      }\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    };\n    return {\n      isIOS: isIOS,\n      isSafari: isSafari,\n      isIPadOS: isIPadOS,\n      isAndroid: isAndroid,\n      isMobile: isMobile,\n      isFirefox: function isFirefox() {\n        return navigator.userAgent.indexOf('Firefox') > -1;\n      },\n      isWebKit: function isWebKit() {\n        return navigator.userAgent.indexOf('WebKit') > -1;\n      },\n      isChrome: function isChrome() {\n        return navigator.userAgent.indexOf('Chrome') > -1;\n      },\n      isOpera: function isOpera() {\n        return /Opera|OPR/.test(navigator.userAgent);\n      },\n      isMac: function isMac() {\n        return navigator.userAgent.indexOf('Mac') > -1;\n      },\n      isWindows: function isWindows() {\n        return navigator.userAgent.indexOf('Windows') > -1;\n      }\n    };\n  }, []);\n  return utils;\n};\nexport default usePlatform;","import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState } from 'react';\nvar useQueue = function useQueue() {\n  var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var _useState = useState(initValues),\n    _useState2 = _slicedToArray(_useState, 2),\n    queue = _useState2[0],\n    setQueue = _useState2[1];\n  return {\n    pop: function pop() {\n      var first = queue[0];\n      setQueue(queue.slice(1));\n      return first;\n    },\n    push: function push(item) {\n      setQueue(function (prev) {\n        return [].concat(_toConsumableArray(prev), [item]);\n      });\n    },\n    get first() {\n      return queue[0];\n    },\n    get last() {\n      return queue[queue.length - 1];\n    },\n    get size() {\n      return queue.length;\n    }\n  };\n};\nexport default useQueue;","import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useMemo, useState } from 'react';\nvar useSet = function useSet(initValue) {\n  var _useState = useState(new Set(initValue)),\n    _useState2 = _slicedToArray(_useState, 2),\n    set = _useState2[0],\n    setSet = _useState2[1];\n  var actions = useMemo(function () {\n    return {\n      add: function add(value) {\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          newSet.add(value);\n          return newSet;\n        });\n      },\n      delete: function _delete(value) {\n        var result = false;\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          result = newSet.delete(value);\n          return newSet;\n        });\n        return result;\n      },\n      clear: function clear() {\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          newSet.clear();\n          return newSet;\n        });\n      },\n      setAll: function setAll(newValue) {\n        return setSet(new Set(newValue));\n      },\n      reset: function reset() {\n        return setSet(new Set(initValue));\n      }\n    };\n  }, [setSet]);\n  var utils = _objectSpread({\n    has: useCallback(function (value) {\n      return set.has(value);\n    }, [set])\n  }, actions);\n  return [set, utils];\n};\nexport default useSet;","import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState } from 'react';\nvar useStack = function useStack() {\n  var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var _useState = useState(initValues),\n    _useState2 = _slicedToArray(_useState, 2),\n    stack = _useState2[0],\n    setStack = _useState2[1];\n  return {\n    pop: function pop() {\n      var first = stack[0];\n      setStack(stack.slice(1));\n      return first;\n    },\n    push: function push(item) {\n      setStack(function (prev) {\n        return [item].concat(_toConsumableArray(prev));\n      });\n    },\n    get first() {\n      return stack[0];\n    },\n    get size() {\n      return stack.length;\n    }\n  };\n};\nexport default useStack;","import { useEffect, useMemo, useRef } from 'react';\nimport { projectName } from \"../constants\";\nvar counter = 0;\nvar useStyle = function useStyle(css) {\n  var id = useMemo(function () {\n    return \"\".concat(projectName, \"-use-style-\") + counter++;\n  }, []);\n  var ref = useRef();\n  useEffect(function () {\n    if (!ref.current) {\n      var style = document.createElement('style');\n      style.id = id;\n      document.head.append(style);\n      ref.current = style;\n    }\n    ref.current.innerText = css;\n    return function () {\n      if (ref.current) {\n        document.head.removeChild(ref.current);\n      }\n    };\n  }, [css]);\n  return id;\n};\nexport default useStyle;","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useCallback, useState } from 'react';\nvar useUpdate = function useUpdate() {\n  var _useState = useState({}),\n    _useState2 = _slicedToArray(_useState, 2),\n    setUpdate = _useState2[1];\n  return useCallback(function () {\n    return setUpdate({});\n  }, []);\n};\nexport default useUpdate;","import useTimeoutFn from \"../useTimeoutFn\";\nimport useUpdate from \"../useUpdate\";\nvar useTimeout = function useTimeout() {\n  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var updator = useUpdate();\n  return useTimeoutFn(updator, {\n    delay: delay,\n    immediate: true\n  });\n};\nexport default useTimeout;","import { useEffect } from 'react';\nvar useTitle = function useTitle(title) {\n  useEffect(function () {\n    document.title = title;\n  }, [title]);\n};\nexport default useTitle;","import { useReducer } from 'react';\nvar toggleReducer = function toggleReducer(state, newValue) {\n  return typeof newValue === 'boolean' ? newValue : !state;\n};\nvar useToggle = function useToggle(initialValue) {\n  return useReducer(toggleReducer, typeof initialValue === 'boolean' ? initialValue : false);\n};\nexport default useToggle;","import { useEffect } from 'react';\nvar isActiveElementEditable = function isActiveElementEditable() {\n  var _document = document,\n    activeElement = _document.activeElement;\n  if (!activeElement) {\n    return;\n  }\n  if (['INPUT', 'TEXTAREA'].includes(activeElement.tagName)) {\n    return true;\n  }\n  return activeElement.hasAttribute('contenteditable');\n};\nvar useTyping = function useTyping(onTyping, ref) {\n  useEffect(function () {\n    var handler = function handler(event) {\n      return isActiveElementEditable() && onTyping(event);\n    };\n    var target = ref !== null && ref !== void 0 && ref.current ? ref.current : document;\n    target === null || target === void 0 ? void 0 : target.addEventListener('keydown', handler);\n    return function () {\n      target === null || target === void 0 ? void 0 : target.removeEventListener('keydown', handler);\n    };\n  }, [onTyping, ref]);\n};\nexport default useTyping;","import { useEffect } from 'react';\nvar useUnmount = function useUnmount(fn) {\n  useEffect(function () {\n    return fn;\n  }, []);\n};\nexport default useUnmount;","import { useEffect, useRef } from 'react';\nvar useUpdateEffect = function useUpdateEffect(effect, deps) {\n  var first = useRef(true);\n  useEffect(function () {\n    if (!first.current) {\n      effect();\n    }\n  }, deps);\n  useEffect(function () {\n    first.current = false;\n  }, []);\n};\nexport default useUpdateEffect;","export { default as useAsyncEffect } from \"./useAsyncEffect\";\nexport { default as useBattery } from \"./useBattery\";\nexport { default as useBeforeUnload } from \"./useBeforeUnload\";\nexport { default as useCookie } from \"./useCookie\";\nexport { default as useCountdown } from \"./useCountdown\";\nexport { default as useCounter } from \"./useCounter\";\nexport { default as useDebounce } from \"./useDebounce\";\nexport { default as useDebounceFn } from \"./useDebounceFn\";\nexport { default as useEffectOnce } from \"./useEffectOnce\";\nexport { default as useEvent } from \"./useEvent\";\nexport { default as useEventAway } from \"./useEventAway\";\nexport { default as useFavicon } from \"./useFavicon\";\nexport { default as useHash } from \"./useHash\";\nexport { default as useHidden } from \"./useHidden\";\nexport { default as useHistory } from \"./useHistory\";\nexport { default as useIntersection } from \"./useIntersection\";\nexport { default as useInterval } from \"./useInterval\";\nexport { default as useLocation } from \"./useLocation\";\nexport { default as useLRU } from \"./useLRU\";\nexport { default as useMap } from \"./useMap\";\nexport { default as useMemoizedFn } from \"./useMemoizedFn\";\nexport { default as useMessage } from \"./useMessage\";\nexport { default as useMount } from \"./useMount\";\nexport { default as useMountedState } from \"./useMountedState\";\nexport { default as useNetwork } from \"./useNetwork\";\nexport { default as usePlatform } from \"./usePlatform\";\nexport { default as useQueue } from \"./useQueue\";\nexport { default as useSet } from \"./useSet\";\nexport { default as useStack } from \"./useStack\";\nexport { default as useStyle } from \"./useStyle\";\nexport { default as useTimeout } from \"./useTimeout\";\nexport { default as useTimeoutFn } from \"./useTimeoutFn\";\nexport { default as useTitle } from \"./useTitle\";\nexport { default as useToggle } from \"./useToggle\";\nexport { default as useTyping } from \"./useTyping\";\nexport { default as useUnmount } from \"./useUnmount\";\nexport { default as useUpdate } from \"./useUpdate\";\nexport { default as useUpdateEffect } from \"./useUpdateEffect\";","\"use strict\";\n(self[\"webpackChunk_N_E\"] = self[\"webpackChunk_N_E\"] || []).push([[47],{\n\n/***/ 72047:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"zX\": function() { return /* reexport */ es_useEvent; }\n});\n\n// UNUSED EXPORTS: useAsyncEffect, useBattery, useBeforeUnload, useCookie, useCountdown, useCounter, useDebounce, useDebounceFn, useEffectOnce, useEventAway, useFavicon, useHash, useHidden, useHistory, useIntersection, useInterval, useLRU, useLocation, useMap, useMemoizedFn, useMessage, useMount, useMountedState, useNetwork, usePlatform, useQueue, useSet, useStack, useStyle, useTimeout, useTimeoutFn, useTitle, useToggle, useTyping, useUnmount, useUpdate, useUpdateEffect\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(67294);\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useAsyncEffect/index.js\n\n\n\n\n\n\nvar useAsyncEffect = function useAsyncEffect(effect, deps) {\n  if (!isFunction(effect)) {\n    throw new Error('effect has to be a function, but got a ' + _typeof(effect));\n  }\n  useEffect(function () {\n    var cancelled = false;\n    var e = effect();\n    function execute() {\n      return _execute.apply(this, arguments);\n    }\n    function _execute() {\n      _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!isAsyncGenerator(e)) {\n                _context.next = 11;\n                break;\n              }\n            case 1:\n              if (false) {}\n              _context.next = 4;\n              return e.next();\n            case 4:\n              result = _context.sent;\n              if (!(result.done || cancelled)) {\n                _context.next = 7;\n                break;\n              }\n              return _context.abrupt(\"break\", 9);\n            case 7:\n              _context.next = 1;\n              break;\n            case 9:\n              _context.next = 13;\n              break;\n            case 11:\n              _context.next = 13;\n              return e;\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _execute.apply(this, arguments);\n    }\n    execute();\n    return function () {\n      cancelled = false;\n    };\n  }, deps);\n};\n/* harmony default export */ var es_useAsyncEffect = ((/* unused pure expression or super */ null && (useAsyncEffect)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useBattery/index.js\n\n\nvar useBattery = function useBattery() {\n  var _useState = useState({\n      isSupport: false\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useEffect(function () {\n    var batteryManager;\n    var updateState = function updateState() {\n      setState(function () {\n        var _batteryManager, _batteryManager2, _batteryManager3, _batteryManager4;\n        return {\n          isSupport: true,\n          level: (_batteryManager = batteryManager) === null || _batteryManager === void 0 ? void 0 : _batteryManager.level,\n          charging: (_batteryManager2 = batteryManager) === null || _batteryManager2 === void 0 ? void 0 : _batteryManager2.charging,\n          chargingTime: (_batteryManager3 = batteryManager) === null || _batteryManager3 === void 0 ? void 0 : _batteryManager3.chargingTime,\n          dischargingTime: (_batteryManager4 = batteryManager) === null || _batteryManager4 === void 0 ? void 0 : _batteryManager4.dischargingTime\n        };\n      });\n    };\n    if ('getBattery' in navigator) {\n      var _getBattery, _ref;\n      (_getBattery = (_ref = navigator).getBattery) === null || _getBattery === void 0 ? void 0 : _getBattery.call(_ref).then(function (battery) {\n        batteryManager = battery;\n        batteryManager.addEventListener('chargingchange', updateState);\n        batteryManager.addEventListener('levelchange', updateState);\n        batteryManager.addEventListener('chargingtimechange', updateState);\n        batteryManager.addEventListener('dischargingtimechange', updateState);\n        updateState();\n      });\n    }\n    return function () {\n      if (batteryManager) {\n        batteryManager.removeEventListener('chargingchange', updateState);\n        batteryManager.removeEventListener('levelchange', updateState);\n        batteryManager.removeEventListener('chargingtimechange', updateState);\n        batteryManager.removeEventListener('dischargingtimechange', updateState);\n      }\n    };\n  }, []);\n  return state;\n};\n/* harmony default export */ var es_useBattery = ((/* unused pure expression or super */ null && (useBattery)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useBeforeUnload/index.js\n\n\nvar useBeforeUnload = function useBeforeUnload(enabled, message) {\n  var handler = useCallback(function (event) {\n    if (isFunction(enabled) ? enabled() : enabled) {\n      event.preventDefault();\n      if (message) {\n        event.returnValue = message;\n      }\n      return message;\n    }\n  }, [enabled, message]);\n  useEffect(function () {\n    if (!enabled) {\n      return;\n    }\n    window.addEventListener('beforeunload', handler);\n    return function () {\n      window.removeEventListener('beforeunload', handler);\n    };\n  }, [enabled, handler]);\n};\n/* harmony default export */ var es_useBeforeUnload = ((/* unused pure expression or super */ null && (useBeforeUnload)));\n;// CONCATENATED MODULE: ./node_modules/js-cookie/dist/js.cookie.mjs\n/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction js_cookie_assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = js_cookie_assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          js_cookie_assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, js_cookie_assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(js_cookie_assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\n\n\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useEffectOnce/index.js\n\nvar useEffectOnce_useEffectOnce = function useEffectOnce(effect) {\n  useEffect(effect, []);\n};\n/* harmony default export */ var es_useEffectOnce = ((/* unused pure expression or super */ null && (useEffectOnce_useEffectOnce)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useMount/index.js\n\nvar useMount_useMount = function useMount(fn) {\n  useEffectOnce(function () {\n    fn();\n  });\n};\n/* harmony default export */ var es_useMount = ((/* unused pure expression or super */ null && (useMount_useMount)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useCookie/index.js\n\n\n\n\nvar useCookie = function useCookie(cookieKey) {\n  var firstMount = useRef(true);\n  var _useState = useState(JSCookie.get(cookieKey)),\n    _useState2 = _slicedToArray(_useState, 2),\n    value = _useState2[0],\n    setValue = _useState2[1];\n  useEffect(function () {\n    if (!firstMount.current) {\n      setValue(JSCookie.get(cookieKey));\n    }\n  }, [cookieKey]);\n  useMount(function () {\n    firstMount.current = false;\n  });\n  var deleteCallback = useCallback(function () {\n    JSCookie.remove(cookieKey);\n    setValue(undefined);\n  }, [cookieKey]);\n  var updateCallback = useCallback(function (nextValue, options) {\n    JSCookie.set(cookieKey, nextValue, options);\n    setValue(nextValue);\n  }, [cookieKey]);\n  return {\n    value: value,\n    delete: deleteCallback,\n    update: updateCallback\n  };\n};\n/* harmony default export */ var es_useCookie = ((/* unused pure expression or super */ null && (useCookie)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useCountdown/index.js\n\n\n\n\n\nvar units = [{\n  name: 'days',\n  num: 86400000\n}, {\n  name: 'hours',\n  num: 3600000\n}, {\n  name: 'minutes',\n  num: 60000\n}, {\n  name: 'seconds',\n  num: 1000\n}, {\n  name: 'milliseconds',\n  num: 1\n}];\nvar getLeftTime = function getLeftTime(targetTime) {\n  return Math.max(targetTime - Date.now(), 0);\n};\nvar formatLeftTime = function formatLeftTime(leftTime) {\n  var remainderTime = leftTime;\n  return units.reduce(function (prev, cur) {\n    prev[cur.name] = Math.floor(remainderTime / cur.num);\n    remainderTime = remainderTime % cur.num;\n    return prev;\n  }, {});\n};\nvar useCountdown = function useCountdown() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if ('leftTime' in params && !isNumber(params.leftTime)) {\n    throw new Error('leftTime has to be a number, but got a ' + _typeof(params.leftTime));\n  }\n  if ('targetTime' in params && !isNumber(params.targetTime)) {\n    throw new Error('targetTime has to be a number, but got a ' + _typeof(params.targetTime));\n  }\n  var ready = useRef(false);\n  var interval = useRef();\n  var targetTime = useMemo(function () {\n    if (isNumber(params.leftTime) && params.leftTime > 0) {\n      return Date.now() + params.leftTime;\n    }\n    return params.targetTime || Date.now();\n  }, [params.targetTime, params.leftTime]);\n  var _useState = useState(function () {\n      return getLeftTime(targetTime);\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    leftTime = _useState2[0],\n    setLeftTime = _useState2[1];\n  var intervalCallback = function intervalCallback() {\n    var leftTime = getLeftTime(targetTime);\n    if (leftTime <= 0) {\n      var _interval$current;\n      ready.current = true;\n      (_interval$current = interval.current) === null || _interval$current === void 0 ? void 0 : _interval$current.clear();\n    }\n    setLeftTime(leftTime);\n  };\n  interval.current = useInterval(intervalCallback, {\n    delay: 1000\n  });\n  useEffect(function () {\n    var _interval$current2, _interval$current3;\n    ready.current = false;\n    intervalCallback();\n    (_interval$current2 = interval.current) === null || _interval$current2 === void 0 ? void 0 : _interval$current2.run();\n    return (_interval$current3 = interval.current) === null || _interval$current3 === void 0 ? void 0 : _interval$current3.clear;\n  }, [targetTime]);\n  var formatedResult = useMemo(function () {\n    return formatLeftTime(leftTime);\n  }, [leftTime]);\n  return {\n    isReady: ready.current,\n    leftTime: leftTime,\n    formatedResult: formatedResult\n  };\n};\n/* harmony default export */ var es_useCountdown = ((/* unused pure expression or super */ null && (useCountdown)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useCounter/index.js\n\n\n\n\nvar resolveValue = function resolveValue(value, min, max) {\n  var result = value;\n  if (isNumber(min)) {\n    result = Math.max(result, min);\n  }\n  if (isNumber(max)) {\n    result = Math.min(result, max);\n  }\n  return result;\n};\nvar useCounter = function useCounter(initValue, options) {\n  if (!isNumber(initValue)) {\n    throw new Error('initValue has to be a number, but got a ' + _typeof(initValue));\n  }\n  var _useState = useState(resolveValue(initValue, options === null || options === void 0 ? void 0 : options.min, options === null || options === void 0 ? void 0 : options.max)),\n    _useState2 = _slicedToArray(_useState, 2),\n    current = _useState2[0],\n    setCurrent = _useState2[1];\n  var initDelta = options && isNumber(options === null || options === void 0 ? void 0 : options.delta) ? options.delta : 1;\n  var setValue = function setValue(newValue) {\n    setCurrent(resolveValue(newValue, options === null || options === void 0 ? void 0 : options.min, options === null || options === void 0 ? void 0 : options.max));\n  };\n  var inc = function inc(delta) {\n    var actDelta = isNumber(delta) ? delta : initDelta;\n    setValue(current + actDelta);\n  };\n  var dec = function dec(delta) {\n    var actDelta = isNumber(delta) ? delta : initDelta;\n    setValue(current - actDelta);\n  };\n  var set = function set(value) {\n    setValue(value);\n  };\n  var reset = function reset(value) {\n    if (isNumber(value)) {\n      setValue(value);\n    } else {\n      setValue(initValue);\n    }\n  };\n  return [current, {\n    inc: inc,\n    dec: dec,\n    set: set,\n    reset: reset\n  }];\n};\n/* harmony default export */ var es_useCounter = ((/* unused pure expression or super */ null && (useCounter)));\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(15671);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(43144);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\nvar defineProperty = __webpack_require__(4942);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n  return desc;\n}\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/isNumber.js\n/* harmony default export */ var utils_isNumber = (function (taregt) {\n  return toString.call(taregt) === '[object Number]' && !Number.isNaN(taregt);\n});\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/lazy-initialize.js\n\nvar lazy_initialize_defineProperty = Object.defineProperty;\n\n\nfunction handleDescriptor(target, key, descriptor) {\n  var configurable = descriptor.configurable,\n      enumerable = descriptor.enumerable,\n      initializer = descriptor.initializer,\n      value = descriptor.value;\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n\n    get: function get() {\n      // This happens if someone accesses the\n      // property directly on the prototype\n      if (this === target) {\n        return;\n      }\n\n      var ret = initializer ? initializer.call(this) : value;\n\n      lazy_initialize_defineProperty(this, key, {\n        configurable: configurable,\n        enumerable: enumerable,\n        writable: true,\n        value: ret\n      });\n\n      return ret;\n    },\n\n\n    set: utils_createDefaultSetter(key)\n  };\n}\n\nfunction lazyInitialize() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return utils_decorate(handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/private/utils.js\nvar utils_typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _desc, _value, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;\n\nfunction _initDefineProp(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction utils_applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that transform-class-properties is enabled.');\n}\n\nfunction utils_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\nvar utils_defineProperty = Object.defineProperty,\n    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    getOwnPropertyNames = Object.getOwnPropertyNames,\n    getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\n\nfunction isDescriptor(desc) {\n  if (!desc || !desc.hasOwnProperty) {\n    return false;\n  }\n\n  var keys = ['value', 'initializer', 'get', 'set'];\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    if (desc.hasOwnProperty(keys[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction utils_decorate(handleDescriptor, entryArgs) {\n  if (isDescriptor(entryArgs[entryArgs.length - 1])) {\n    return handleDescriptor.apply(undefined, utils_toConsumableArray(entryArgs).concat([[]]));\n  } else {\n    return function () {\n      return handleDescriptor.apply(undefined, utils_toConsumableArray(Array.prototype.slice.call(arguments)).concat([entryArgs]));\n    };\n  }\n}\n\nvar Meta = (_class = function Meta() {\n  _classCallCheck(this, Meta);\n\n  _initDefineProp(this, 'debounceTimeoutIds', _descriptor, this);\n\n  _initDefineProp(this, 'throttleTimeoutIds', _descriptor2, this);\n\n  _initDefineProp(this, 'throttlePreviousTimestamps', _descriptor3, this);\n\n  _initDefineProp(this, 'throttleTrailingArgs', _descriptor4, this);\n\n  _initDefineProp(this, 'profileLastRan', _descriptor5, this);\n}, (_descriptor = utils_applyDecoratedDescriptor(_class.prototype, 'debounceTimeoutIds', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor2 = utils_applyDecoratedDescriptor(_class.prototype, 'throttleTimeoutIds', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor3 = utils_applyDecoratedDescriptor(_class.prototype, 'throttlePreviousTimestamps', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return {};\n  }\n}), _descriptor4 = utils_applyDecoratedDescriptor(_class.prototype, 'throttleTrailingArgs', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return null;\n  }\n}), _descriptor5 = utils_applyDecoratedDescriptor(_class.prototype, 'profileLastRan', [lazyInitialize], {\n  enumerable: true,\n  initializer: function initializer() {\n    return null;\n  }\n})), _class);\n\n\nvar META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';\n\nfunction utils_metaFor(obj) {\n  if (obj.hasOwnProperty(META_KEY) === false) {\n    utils_defineProperty(obj, META_KEY, {\n      // Defaults: NOT enumerable, configurable, or writable\n      value: new Meta()\n    });\n  }\n\n  return obj[META_KEY];\n}\n\nvar utils_getOwnKeys = getOwnPropertySymbols ? function (object) {\n  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n} : getOwnPropertyNames;\n\nfunction utils_getOwnPropertyDescriptors(obj) {\n  var descs = {};\n\n  utils_getOwnKeys(obj).forEach(function (key) {\n    return descs[key] = getOwnPropertyDescriptor(obj, key);\n  });\n\n  return descs;\n}\n\nfunction utils_createDefaultSetter(key) {\n  return function set(newValue) {\n    Object.defineProperty(this, key, {\n      configurable: true,\n      writable: true,\n      // IS enumerable when reassigned by the outside word\n      enumerable: true,\n      value: newValue\n    });\n\n    return newValue;\n  };\n}\n\nfunction bind(fn, context) {\n  if (fn.bind) {\n    return fn.bind(context);\n  } else {\n    return function __autobind__() {\n      return fn.apply(context, arguments);\n    };\n  }\n}\n\nvar utils_warn = function () {\n  if ((typeof console === 'undefined' ? 'undefined' : utils_typeof(console)) !== 'object' || !console || typeof console.warn !== 'function') {\n    return function () {};\n  } else {\n    return bind(console.warn, console);\n  }\n}();\n\nvar seenDeprecations = {};\nfunction utils_internalDeprecation(msg) {\n  if (seenDeprecations[msg] !== true) {\n    seenDeprecations[msg] = true;\n    utils_warn('DEPRECATION: ' + msg);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/override.js\nvar override_typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction override_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';\nvar FUNCTION_REGEXP = /^function ([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?(\\([^\\)]*\\))[\\s\\S]+$/;\n\nvar SyntaxErrorReporter = function () {\n  _createClass(SyntaxErrorReporter, [{\n    key: '_getTopic',\n    value: function _getTopic(descriptor) {\n      if (descriptor === undefined) {\n        return null;\n      }\n\n      if ('value' in descriptor) {\n        return descriptor.value;\n      }\n\n      if ('get' in descriptor) {\n        return descriptor.get;\n      }\n\n      if ('set' in descriptor) {\n        return descriptor.set;\n      }\n    }\n  }, {\n    key: '_extractTopicSignature',\n    value: function _extractTopicSignature(topic) {\n      switch (typeof topic === 'undefined' ? 'undefined' : override_typeof(topic)) {\n        case 'function':\n          return this._extractFunctionSignature(topic);\n        default:\n          return this.key;\n      }\n    }\n  }, {\n    key: '_extractFunctionSignature',\n    value: function _extractFunctionSignature(fn) {\n      var _this = this;\n\n      return fn.toString().replace(FUNCTION_REGEXP, function (match) {\n        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;\n        var params = arguments[2];\n        return name + params;\n      });\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      return this.childDescriptor.key;\n    }\n  }, {\n    key: 'parentNotation',\n    get: function get() {\n      return this.parentKlass.constructor.name + '#' + this.parentPropertySignature;\n    }\n  }, {\n    key: 'childNotation',\n    get: function get() {\n      return this.childKlass.constructor.name + '#' + this.childPropertySignature;\n    }\n  }, {\n    key: 'parentTopic',\n    get: function get() {\n      return this._getTopic(this.parentDescriptor);\n    }\n  }, {\n    key: 'childTopic',\n    get: function get() {\n      return this._getTopic(this.childDescriptor);\n    }\n  }, {\n    key: 'parentPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.parentTopic);\n    }\n  }, {\n    key: 'childPropertySignature',\n    get: function get() {\n      return this._extractTopicSignature(this.childTopic);\n    }\n  }]);\n\n  function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {\n    override_classCallCheck(this, SyntaxErrorReporter);\n\n    this.parentKlass = parentKlass;\n    this.childKlass = childKlass;\n    this.parentDescriptor = parentDescriptor;\n    this.childDescriptor = childDescriptor;\n  }\n\n  _createClass(SyntaxErrorReporter, [{\n    key: 'assert',\n    value: function assert(condition) {\n      var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n      if (condition !== true) {\n        this.error(GENERIC_FUNCTION_ERROR + msg);\n      }\n    }\n  }, {\n    key: 'error',\n    value: function error(msg) {\n      var _this2 = this;\n\n      msg = msg\n      // Replace lazily, because they actually might not\n      // be available in all cases\n      .replace('{parent}', function (m) {\n        return _this2.parentNotation;\n      }).replace('{child}', function (m) {\n        return _this2.childNotation;\n      });\n      throw new SyntaxError(msg);\n    }\n  }]);\n\n  return SyntaxErrorReporter;\n}();\n\nfunction getDescriptorType(descriptor) {\n  if (descriptor.hasOwnProperty('value')) {\n    return 'data';\n  }\n\n  if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {\n    return 'accessor';\n  }\n\n  // If none of them exist, browsers treat it as\n  // a data descriptor with a value of `undefined`\n  return 'data';\n}\n\nfunction checkFunctionSignatures(parent, child, reporter) {\n  reporter.assert(parent.length === child.length);\n}\n\nfunction checkDataDescriptors(parent, child, reporter) {\n  var parentValueType = override_typeof(parent.value);\n  var childValueType = override_typeof(child.value);\n\n  if (parentValueType === 'undefined' && childValueType === 'undefined') {\n    // class properties can be any expression, which isn't ran until the\n    // the instance is created, so we can't reliably get type information\n    // for them yet (per spec). Perhaps when Babel includes flow-type info\n    // in runtime? Tried regex solutions, but super hacky and only feasible\n    // on primitives, which is confusing for usage...\n    reporter.error('descriptor values are both undefined. (class properties are are not currently supported)\\'');\n  }\n\n  if (parentValueType !== childValueType) {\n    var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined;\n    // Even though we don't support class properties, this\n    // will still handle more than just functions, just in case.\n    // Shadowing an undefined value is an error if the inherited\n    // value was undefined (usually a class property, not a method)\n    if (isFunctionOverUndefined || parentValueType !== undefined) {\n      reporter.error('value types do not match. {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n    }\n  }\n\n  // Switch, in preparation for supporting more types\n  switch (childValueType) {\n    case 'function':\n      checkFunctionSignatures(parent.value, child.value, reporter);\n      break;\n\n    default:\n      reporter.error('Unexpected error. Please file a bug with: {parent} is \"' + parentValueType + '\", {child} is \"' + childValueType + '\"');\n      break;\n  }\n}\n\nfunction checkAccessorDescriptors(parent, child, reporter) {\n  var parentHasGetter = typeof parent.get === 'function';\n  var childHasGetter = typeof child.get === 'function';\n  var parentHasSetter = typeof parent.set === 'function';\n  var childHasSetter = typeof child.set === 'function';\n\n  if (parentHasGetter || childHasGetter) {\n    if (!parentHasGetter && parentHasSetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    if (!childHasGetter && childHasSetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    checkFunctionSignatures(parent.get, child.get, reporter);\n  }\n\n  if (parentHasSetter || childHasSetter) {\n    if (!parentHasSetter && parentHasGetter) {\n      reporter.error('{parent} is getter but {child} is setter');\n    }\n\n    if (!childHasSetter && childHasGetter) {\n      reporter.error('{parent} is setter but {child} is getter');\n    }\n\n    checkFunctionSignatures(parent.set, child.set, reporter);\n  }\n}\n\nfunction checkDescriptors(parent, child, reporter) {\n  var parentType = getDescriptorType(parent);\n  var childType = getDescriptorType(child);\n\n  if (parentType !== childType) {\n    reporter.error('descriptor types do not match. {parent} is \"' + parentType + '\", {child} is \"' + childType + '\"');\n  }\n\n  switch (childType) {\n    case 'data':\n      checkDataDescriptors(parent, child, reporter);\n      break;\n\n    case 'accessor':\n      checkAccessorDescriptors(parent, child, reporter);\n      break;\n  }\n}\n\nvar suggestionTransforms = [function (key) {\n  return key.toLowerCase();\n}, function (key) {\n  return key.toUpperCase();\n}, function (key) {\n  return key + 's';\n}, function (key) {\n  return key.slice(0, -1);\n}, function (key) {\n  return key.slice(1, key.length);\n}];\n\nfunction findPossibleAlternatives(superKlass, key) {\n  for (var i = 0, l = suggestionTransforms.length; i < l; i++) {\n    var fn = suggestionTransforms[i];\n    var suggestion = fn(key);\n\n    if (suggestion in superKlass) {\n      return suggestion;\n    }\n  }\n\n  return null;\n}\n\nfunction override_handleDescriptor(target, key, descriptor) {\n  descriptor.key = key;\n  var superKlass = Object.getPrototypeOf(target);\n  var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);\n  var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);\n\n  if (superDescriptor === undefined) {\n    var suggestedKey = findPossibleAlternatives(superKlass, key);\n    var suggestion = suggestedKey ? '\\n\\n  Did you mean \"' + suggestedKey + '\"?' : '';\n    reporter.error('No descriptor matching {child} was found on the prototype chain.' + suggestion);\n  }\n\n  checkDescriptors(superDescriptor, descriptor, reporter);\n\n  return descriptor;\n}\n\nfunction override() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(override_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/deprecate.js\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar deprecate_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\nvar DEFAULT_MSG = 'This function will be removed in future versions.';\n\nfunction deprecate_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = deprecate_slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      msg = _ref2$ === undefined ? DEFAULT_MSG : _ref2$,\n      _ref2$2 = _ref2[1],\n      options = _ref2$2 === undefined ? {} : _ref2$2;\n\n  if (typeof descriptor.value !== 'function') {\n    throw new SyntaxError('Only functions can be marked as deprecated');\n  }\n\n  var methodSignature = target.constructor.name + '#' + key;\n\n  if (options.url) {\n    msg += '\\n\\n    See ' + options.url + ' for more details.\\n\\n';\n  }\n\n  return _extends({}, descriptor, {\n    value: function deprecationWrapper() {\n      warn('DEPRECATION ' + methodSignature + ': ' + msg);\n      return descriptor.value.apply(this, arguments);\n    }\n  });\n}\n\nfunction deprecate() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(deprecate_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/suppress-warnings.js\nvar suppress_warnings_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar suppress_warnings_typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nfunction suppressedWarningNoop() {\n  // Warnings are currently suppressed via @suppressWarnings\n}\n\nfunction applyWithoutWarnings(context, fn, args) {\n  if ((typeof console === 'undefined' ? 'undefined' : suppress_warnings_typeof(console)) === 'object') {\n    var nativeWarn = console.warn;\n    console.warn = suppressedWarningNoop;\n    var ret = fn.apply(context, args);\n    console.warn = nativeWarn;\n    return ret;\n  } else {\n    return fn.apply(context, args);\n  }\n}\n\nfunction suppress_warnings_handleDescriptor(target, key, descriptor) {\n  return suppress_warnings_extends({}, descriptor, {\n    value: function suppressWarningsWrapper() {\n      return applyWithoutWarnings(this, descriptor.value, arguments);\n    }\n  });\n}\n\nfunction suppressWarnings() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(suppress_warnings_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/memoize.js\nvar memoize_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return { fn: fn, wrapKey: wrapKey };\n}\n\nfunction memoize_handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n\n  return memoize_extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nfunction memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(memoize_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/autobind.js\nfunction autobind_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\nvar autobind_defineProperty = Object.defineProperty,\n    getPrototypeOf = Object.getPrototypeOf;\n\n\nvar mapStore = void 0;\n\nfunction getBoundSuper(obj, fn) {\n  if (typeof WeakMap === 'undefined') {\n    throw new Error('Using @autobind on ' + fn.name + '() requires WeakMap support due to its use of super.' + fn.name + '()\\n      See https://github.com/jayphelps/core-decorators.js/issues/20');\n  }\n\n  if (!mapStore) {\n    mapStore = new WeakMap();\n  }\n\n  if (mapStore.has(obj) === false) {\n    mapStore.set(obj, new WeakMap());\n  }\n\n  var superStore = mapStore.get(obj);\n\n  if (superStore.has(fn) === false) {\n    superStore.set(fn, bind(fn, obj));\n  }\n\n  return superStore.get(fn);\n}\n\nfunction autobindClass(klass) {\n  var descs = utils_getOwnPropertyDescriptors(klass.prototype);\n  var keys = utils_getOwnKeys(descs);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    var desc = descs[key];\n\n    if (typeof desc.value !== 'function' || key === 'constructor') {\n      continue;\n    }\n\n    autobind_defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));\n  }\n}\n\nfunction autobindMethod(target, key, _ref) {\n  var fn = _ref.value,\n      configurable = _ref.configurable,\n      enumerable = _ref.enumerable;\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@autobind can only be used on functions, not: ' + fn);\n  }\n\n  var constructor = target.constructor;\n\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n\n    get: function get() {\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on the prototype on which it is\n      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)\n      if (this === target) {\n        return fn;\n      }\n\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on a prototype but it was found\n      // up the chain, not defined directly on it\n      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype\n      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {\n        return fn;\n      }\n\n      // Autobound method calling super.sameMethod() which is also autobound and so on.\n      if (this.constructor !== constructor && key in this.constructor.prototype) {\n        return getBoundSuper(this, fn);\n      }\n\n      var boundFn = bind(fn, this);\n\n      autobind_defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        // NOT enumerable when it's a bound method\n        enumerable: false,\n        value: boundFn\n      });\n\n      return boundFn;\n    },\n\n    set: utils_createDefaultSetter(key)\n  };\n}\n\nfunction handle(args) {\n  if (args.length === 1) {\n    return autobindClass.apply(undefined, autobind_toConsumableArray(args));\n  } else {\n    return autobindMethod.apply(undefined, autobind_toConsumableArray(args));\n  }\n}\n\nfunction autobind() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 0) {\n    return function () {\n      return handle(arguments);\n    };\n  } else {\n    return handle(args);\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/readonly.js\n\n\nfunction readonly_handleDescriptor(target, key, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nfunction readonly() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return utils_decorate(readonly_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/enumerable.js\n\n\nfunction enumerable_handleDescriptor(target, key, descriptor) {\n  descriptor.enumerable = true;\n  return descriptor;\n}\n\nfunction enumerable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(enumerable_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/nonenumerable.js\n\n\nfunction nonenumerable_handleDescriptor(target, key, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n\nfunction nonenumerable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(nonenumerable_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/nonconfigurable.js\n\n\nfunction nonconfigurable_handleDescriptor(target, key, descriptor) {\n  descriptor.configurable = false;\n  return descriptor;\n}\n\nfunction nonconfigurable() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(nonconfigurable_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/debounce.js\nvar debounce_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar debounce_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\nvar DEFAULT_TIMEOUT = 300;\n\nfunction debounce_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = debounce_slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      wait = _ref2$ === undefined ? DEFAULT_TIMEOUT : _ref2$,\n      _ref2$2 = _ref2[1],\n      immediate = _ref2$2 === undefined ? false : _ref2$2;\n\n  var callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be debounced');\n  }\n\n  return debounce_extends({}, descriptor, {\n    value: function value() {\n      var _this = this;\n\n      var _metaFor = metaFor(this),\n          debounceTimeoutIds = _metaFor.debounceTimeoutIds;\n\n      var timeout = debounceTimeoutIds[key];\n      var callNow = immediate && !timeout;\n      var args = arguments;\n\n      clearTimeout(timeout);\n\n      debounceTimeoutIds[key] = setTimeout(function () {\n        delete debounceTimeoutIds[key];\n        if (!immediate) {\n          callback.apply(_this, args);\n        }\n      }, wait);\n\n      if (callNow) {\n        callback.apply(this, args);\n      }\n    }\n  });\n}\n\nfunction debounce() {\n  internalDeprecation('@debounce is deprecated and will be removed shortly. Use @debounce from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(debounce_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/throttle.js\nvar throttle_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar throttle_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\nvar throttle_DEFAULT_TIMEOUT = 300;\n\nfunction throttle_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = throttle_slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      wait = _ref2$ === undefined ? throttle_DEFAULT_TIMEOUT : _ref2$,\n      _ref2$2 = _ref2[1],\n      options = _ref2$2 === undefined ? {} : _ref2$2;\n\n  var callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be throttled');\n  }\n\n  if (options.leading !== false) {\n    options.leading = true;\n  }\n\n  if (options.trailing !== false) {\n    options.trailing = true;\n  }\n\n  return throttle_extends({}, descriptor, {\n    value: function value() {\n      var _this = this;\n\n      var meta = metaFor(this);\n      var throttleTimeoutIds = meta.throttleTimeoutIds,\n          throttlePreviousTimestamps = meta.throttlePreviousTimestamps;\n\n      var timeout = throttleTimeoutIds[key];\n      // last execute timestamp\n      var previous = throttlePreviousTimestamps[key] || 0;\n      var now = Date.now();\n\n      if (options.trailing) {\n        meta.throttleTrailingArgs = arguments;\n      }\n\n      // if first be called and disable the execution on the leading edge\n      // set last execute timestamp to now\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n\n      var remaining = wait - (now - previous);\n\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        delete throttleTimeoutIds[key];\n        throttlePreviousTimestamps[key] = now;\n        callback.apply(this, arguments);\n      } else if (!timeout && options.trailing) {\n        throttleTimeoutIds[key] = setTimeout(function () {\n          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();\n          delete throttleTimeoutIds[key];\n          callback.apply(_this, meta.throttleTrailingArgs);\n          // don't leak memory!\n          meta.throttleTrailingArgs = null;\n        }, remaining);\n      }\n    }\n  });\n}\n\nfunction throttle() {\n  internalDeprecation('@throttle is deprecated and will be removed shortly. Use @throttle from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(throttle_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/decorate.js\nfunction decorate_toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }\n\n\nvar decorate_defineProperty = Object.defineProperty;\n\n\nfunction decorate_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = _toArray(_ref),\n      decorator = _ref2[0],\n      args = _ref2.slice(1);\n\n  var configurable = descriptor.configurable,\n      enumerable = descriptor.enumerable,\n      writable = descriptor.writable;\n\n  var originalGet = descriptor.get;\n  var originalSet = descriptor.set;\n  var originalValue = descriptor.value;\n  var isGetter = !!originalGet;\n\n  return {\n    configurable: configurable,\n    enumerable: enumerable,\n    get: function get() {\n      var fn = isGetter ? originalGet.call(this) : originalValue;\n      var value = decorator.call.apply(decorator, [this, fn].concat(decorate_toConsumableArray(args)));\n\n      if (isGetter) {\n        return value;\n      } else {\n        var desc = {\n          configurable: configurable,\n          enumerable: enumerable\n        };\n\n        desc.value = value;\n        desc.writable = writable;\n\n        decorate_defineProperty(this, key, desc);\n\n        return value;\n      }\n    },\n\n    set: isGetter ? originalSet : createDefaultSetter()\n  };\n}\n\nfunction decorate_decorate() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return _decorate(decorate_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/mixin.js\nvar mixin_typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\n\nvar mixin_defineProperty = Object.defineProperty,\n    mixin_getPrototypeOf = Object.getPrototypeOf;\n\n\nfunction buggySymbol(symbol) {\n  return Object.prototype.toString.call(symbol) === '[object Symbol]' && (typeof symbol === 'undefined' ? 'undefined' : mixin_typeof(symbol)) === 'object';\n}\n\nfunction hasProperty(prop, obj) {\n  // We have to traverse manually prototypes' chain for polyfilled ES6 Symbols\n  // like \"in\" operator does.\n  // I.e.: Babel 5 Symbol polyfill stores every created symbol in Object.prototype.\n  // That's why we cannot use construction like \"prop in obj\" to check, if needed\n  // prop actually exists in given object/prototypes' chain.\n  if (buggySymbol(prop)) {\n    do {\n      if (obj === Object.prototype) {\n        // Polyfill assigns undefined as value for stored symbol key.\n        // We can assume in this special case if there is nothing assigned it doesn't exist.\n        return typeof obj[prop] !== 'undefined';\n      }\n      if (obj.hasOwnProperty(prop)) {\n        return true;\n      }\n    } while (obj = mixin_getPrototypeOf(obj));\n    return false;\n  } else {\n    return prop in obj;\n  }\n}\n\nfunction handleClass(target, mixins) {\n  if (!mixins.length) {\n    throw new SyntaxError('@mixin() class ' + target.name + ' requires at least one mixin as an argument');\n  }\n\n  for (var i = 0, l = mixins.length; i < l; i++) {\n    var descs = getOwnPropertyDescriptors(mixins[i]);\n    var keys = getOwnKeys(descs);\n\n    for (var j = 0, k = keys.length; j < k; j++) {\n      var key = keys[j];\n\n      if (!hasProperty(key, target.prototype)) {\n        mixin_defineProperty(target.prototype, key, descs[key]);\n      }\n    }\n  }\n}\n\nfunction mixin() {\n  for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {\n    mixins[_key] = arguments[_key];\n  }\n\n  internalDeprecation('@mixin is deprecated and will be removed shortly. Use @mixin from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  if (typeof mixins[0] === 'function') {\n    return handleClass(mixins[0], []);\n  } else {\n    return function (target) {\n      return handleClass(target, mixins);\n    };\n  }\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/time.js\nvar time_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar time_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\nvar labels = {};\n\n// Exported for mocking in tests\nvar defaultConsole = {\n  time: console.time ? console.time.bind(console) : function (label) {\n    labels[label] = new Date();\n  },\n  timeEnd: console.timeEnd ? console.timeEnd.bind(console) : function (label) {\n    var timeNow = new Date();\n    var timeTaken = timeNow - labels[label];\n    delete labels[label];\n    console.log(label + ': ' + timeTaken + 'ms');\n  }\n};\n\nvar count = 0;\n\nfunction time_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = time_slicedToArray(_ref, 2),\n      _ref2$ = _ref2[0],\n      prefix = _ref2$ === undefined ? null : _ref2$,\n      _ref2$2 = _ref2[1],\n      console = _ref2$2 === undefined ? defaultConsole : _ref2$2;\n\n  var fn = descriptor.value;\n\n  if (prefix === null) {\n    prefix = target.constructor.name + '.' + key;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@time can only be used on functions, not: ' + fn);\n  }\n\n  return time_extends({}, descriptor, {\n    value: function value() {\n      var label = prefix + '-' + count;\n      count++;\n      console.time(label);\n\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        console.timeEnd(label);\n      }\n    }\n  });\n}\n\nfunction time() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(time_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/extendDescriptor.js\nvar extendDescriptor_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n\nvar extendDescriptor_getPrototypeOf = Object.getPrototypeOf,\n    extendDescriptor_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\nfunction extendDescriptor_handleDescriptor(target, key, descriptor) {\n  var superKlass = extendDescriptor_getPrototypeOf(target);\n  var superDesc = extendDescriptor_getOwnPropertyDescriptor(superKlass, key);\n\n  return extendDescriptor_extends({}, superDesc, {\n    value: descriptor.value,\n    initializer: descriptor.initializer,\n    get: descriptor.get || superDesc.get,\n    set: descriptor.set || superDesc.set\n  });\n}\n\nfunction extendDescriptor() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return decorate(extendDescriptor_handleDescriptor, args);\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/profile.js\nvar profile_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar profile_slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\nvar oc = console;\n\n// Exported for mocking in tests\nvar profile_defaultConsole = {\n  profile: console.profile ? bind(console.profile, console) : function () {},\n  profileEnd: console.profileEnd ? bind(console.profileEnd, console) : function () {},\n  warn: utils_warn\n};\n\nfunction profile_handleDescriptor(target, key, descriptor, _ref) {\n  var _ref2 = profile_slicedToArray(_ref, 3),\n      _ref2$ = _ref2[0],\n      prefix = _ref2$ === undefined ? null : _ref2$,\n      _ref2$2 = _ref2[1],\n      onceThrottleOrFunction = _ref2$2 === undefined ? false : _ref2$2,\n      _ref2$3 = _ref2[2],\n      console = _ref2$3 === undefined ? profile_defaultConsole : _ref2$3;\n\n  if (!profile.__enabled) {\n    if (!profile.__warned) {\n      console.warn('console.profile is not supported. All @profile decorators are disabled.');\n      profile.__warned = true;\n    }\n    return descriptor;\n  }\n\n  var fn = descriptor.value;\n\n  if (prefix === null) {\n    prefix = target.constructor.name + '.' + key;\n  }\n\n  if (typeof fn !== 'function') {\n    throw new SyntaxError('@profile can only be used on functions, not: ' + fn);\n  }\n\n  return profile_extends({}, descriptor, {\n    value: function value() {\n      var now = Date.now();\n      var meta = utils_metaFor(this);\n      if (onceThrottleOrFunction === true && !meta.profileLastRan || onceThrottleOrFunction === false || typeof onceThrottleOrFunction === 'number' && now - meta.profileLastRan > onceThrottleOrFunction || typeof onceThrottleOrFunction === 'function' && onceThrottleOrFunction.apply(this, arguments)) {\n        console.profile(prefix);\n        meta.profileLastRan = now;\n      }\n\n      try {\n        return fn.apply(this, arguments);\n      } finally {\n        console.profileEnd(prefix);\n      }\n    }\n  });\n}\n\nfunction profile() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return utils_decorate(profile_handleDescriptor, args);\n}\n\n// Only Chrome, Firefox, and Edge support profile.\n// Exposing properties for testing.\nprofile.__enabled = !!console.profile;\nprofile.__warned = false;\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/applyDecorators.js\nvar applyDecorators_defineProperty = Object.defineProperty,\n    applyDecorators_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n\nfunction applyDecorators(Class, props) {\n  var prototype = Class.prototype;\n\n\n  for (var key in props) {\n    var decorators = props[key];\n\n    for (var i = 0, l = decorators.length; i < l; i++) {\n      var decorator = decorators[i];\n\n      applyDecorators_defineProperty(prototype, key, decorator(prototype, key, applyDecorators_getOwnPropertyDescriptor(prototype, key)));\n    }\n  }\n\n  return Class;\n}\n;// CONCATENATED MODULE: ./node_modules/core-decorators/es/core-decorators.js\n/**\n * core-decorators.js\n * (c) 2017 Jay Phelps and contributors\n * MIT Licensed\n * https://github.com/jayphelps/core-decorators.js\n * @license\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Helper to apply decorators to a class without transpiler support\n\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/isBrowser.js\nvar isBrowser = function isBrowser() {\n  return typeof window !== 'undefined';\n};\n/* harmony default export */ var utils_isBrowser = (isBrowser);\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/work-timer/types.js\nvar MsgType = /*#__PURE__*/function (MsgType) {\n  MsgType[MsgType[\"Create\"] = 0] = \"Create\";\n  MsgType[MsgType[\"Execute\"] = 1] = \"Execute\";\n  MsgType[MsgType[\"Clear\"] = 2] = \"Clear\";\n  return MsgType;\n}({});\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/work-timer/timer.worker.js\n\n\nif (utils_isBrowser()) {\n  var webWorker = self;\n  webWorker.addEventListener('message', function (message) {\n    var data = message.data;\n    switch (data.type) {\n      case MsgType.Create:\n        {\n          var $timer = setTimeout(function () {\n            webWorker.postMessage({\n              taskId: data.taskId,\n              type: MsgType.Execute\n            });\n            clearTimeout($timer);\n          }, data.wait);\n          webWorker.postMessage({\n            taskId: data.taskId,\n            timer: $timer,\n            type: MsgType.Create\n          });\n          break;\n        }\n      case MsgType.Clear:\n        {\n          clearTimeout(data.timerId);\n          webWorker.postMessage({\n            taskId: data.taskId,\n            type: MsgType.Clear\n          });\n          break;\n        }\n    }\n  });\n}\n/* harmony default export */ var timer_worker = (null);\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/work-timer/index.js\n\n\n\n\n\n\nvar work_timer_class, _class2, work_timer_descriptor;\n\n\n\n\nvar taskSeed = 1;\nvar createTask = function createTask() {\n  return {\n    taskId: taskSeed++\n  };\n};\nvar createMsg = function createMsg(type, taskId) {\n  return {\n    type: type,\n    taskId: taskId\n  };\n};\nvar work_timer_WorkerTimer = autobind(work_timer_class = (_class2 = /*#__PURE__*/function () {\n  function WorkerTimer() {\n    (0,classCallCheck/* default */.Z)(this, WorkerTimer);\n    (0,defineProperty/* default */.Z)(this, \"taskMap\", new Map());\n    _initializerDefineProperty(this, \"worker\", work_timer_descriptor, this);\n    this.init();\n  }\n  (0,createClass/* default */.Z)(WorkerTimer, [{\n    key: \"init\",\n    value: function init() {\n      this.onMessage();\n    }\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(callback) {\n      var _this = this;\n      var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var newTask = createTask();\n      newTask.handler = callback;\n      this.taskMap.set(newTask.taskId, newTask);\n      var msg = createMsg(MsgType.Create, newTask.taskId);\n      msg.wait = wait;\n      this.worker.postMessage(msg);\n      return function () {\n        _this.clear(newTask.taskId);\n      };\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(id) {\n      if (utils_isNumber(id) && this.taskMap.has(id)) {\n        var _this$taskMap$get;\n        var msg = createMsg(MsgType.Create, id);\n        msg.timer = (_this$taskMap$get = this.taskMap.get(id)) === null || _this$taskMap$get === void 0 ? void 0 : _this$taskMap$get.timer;\n        this.worker.postMessage(msg);\n      }\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage() {\n      var _this2 = this;\n      this.worker.onmessage = function (event) {\n        var data = event.data;\n        switch (data.type) {\n          case MsgType.Create:\n            {\n              var task = _this2.taskMap.get(data.taskId);\n              if (!task) {\n                return;\n              }\n              task.timer = data.timer;\n              _this2.taskMap.set(data.taskId, task);\n              break;\n            }\n          case MsgType.Execute:\n            {\n              var _task$handler;\n              var _task = _this2.taskMap.get(data.taskId);\n              if (!_task) {\n                return;\n              }\n              (_task$handler = _task.handler) === null || _task$handler === void 0 ? void 0 : _task$handler.call(_task);\n              _this2.taskMap.delete(_task.taskId);\n              break;\n            }\n          case MsgType.Clear:\n            {\n              _this2.taskMap.delete(data.taskId);\n              break;\n            }\n        }\n      };\n    }\n  }]);\n  return WorkerTimer;\n}(), (work_timer_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"worker\", [readonly], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return new timer_worker('');\n  }\n})), _class2)) || work_timer_class;\n/* harmony default export */ var work_timer = ((/* unused pure expression or super */ null && (work_timer_WorkerTimer)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/work-timer/helper.js\n\nvar install;\nvar helper_getWorkerTimer = function getWorkerTimer() {\n  if (install) {\n    return install;\n  }\n  return install = new WorkerTimer();\n};\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useLatest/index.js\n\nvar useLatest_useLatest = function useLatest(value) {\n  var ref = useRef(value);\n  ref.current = value;\n  return ref;\n};\n/* harmony default export */ var es_useLatest = ((/* unused pure expression or super */ null && (useLatest_useLatest)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useTimeoutFn/index.js\n\n\n\n\n\nvar clearTimer = function clearTimer() {\n  var useWorker = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var timer = arguments.length > 1 ? arguments[1] : undefined;\n  if (useWorker) {\n    timer === null || timer === void 0 ? void 0 : timer();\n  }\n  clearTimeout(timer);\n};\nvar useTimeoutFn_useTimeoutFn = function useTimeoutFn(fn, options) {\n  if (!isFunction(fn)) {\n    throw new Error('fn has to be a function, but got a ' + _typeof(fn));\n  }\n  var timeoutRef = useRef();\n  var readyRef = useRef(null);\n  var fnRef = useLatest(fn);\n  var delay = (options === null || options === void 0 ? void 0 : options.delay) || 0;\n  var reset = useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    readyRef.current = false;\n    if (timeoutRef.current) {\n      clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n    }\n    timeoutRef.current = (options !== null && options !== void 0 && options.useWorker ? getWorkerTimer().setTimeout : setTimeout)(function () {\n      var _fnRef$current;\n      readyRef.current = true;\n      (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));\n      if (timeoutRef.current) {\n        clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n      }\n    }, delay);\n  }, [delay]);\n  var isReady = useCallback(function () {\n    return readyRef.current;\n  }, []);\n  var cancel = useCallback(function () {\n    readyRef.current = null;\n    if (timeoutRef.current) {\n      clearTimer(options === null || options === void 0 ? void 0 : options.useWorker, timeoutRef.current);\n    }\n  }, []);\n  useEffect(function () {\n    if (options !== null && options !== void 0 && options.immediate) {\n      reset();\n      return cancel;\n    }\n  }, []);\n  return {\n    run: reset,\n    isReady: isReady,\n    reset: reset,\n    cancel: cancel\n  };\n};\n/* harmony default export */ var es_useTimeoutFn = ((/* unused pure expression or super */ null && (useTimeoutFn_useTimeoutFn)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useDebounce/index.js\n\n\n\nvar useDebounce = function useDebounce(value) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var _useState = useState(value),\n    _useState2 = _slicedToArray(_useState, 2),\n    debounced = _useState2[0],\n    setDebounced = _useState2[1];\n  var _useTimeoutFn = useTimeoutFn(function () {\n      setDebounced(value);\n    }, {\n      delay: wait\n    }),\n    run = _useTimeoutFn.run;\n  useEffect(function () {\n    run();\n  }, [value]);\n  return debounced;\n};\n/* harmony default export */ var es_useDebounce = ((/* unused pure expression or super */ null && (useDebounce)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useDebounceFn/index.js\n\nvar useDebounceFn = function useDebounceFn(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return useTimeoutFn(fn, {\n    delay: wait\n  });\n};\n/* harmony default export */ var es_useDebounceFn = ((/* unused pure expression or super */ null && (useDebounceFn)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useEvent/index.js\n\n\nvar defaultTarget = utils_isBrowser() ? window : null;\nvar useEvent = function useEvent(eventName, handler) {\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultTarget;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  (0,react.useEffect)(function () {\n    if (!handler) {\n      return;\n    }\n    if (!target) {\n      return;\n    }\n    target.addEventListener(eventName, handler, options);\n    return function () {\n      target.removeEventListener(eventName, handler, options);\n    };\n  }, []);\n};\n/* harmony default export */ var es_useEvent = (useEvent);\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useEventAway/index.js\n\nvar _excluded = (/* unused pure expression or super */ null && ([\"eventNames\"]));\n\nvar defaultEvents = (/* unused pure expression or super */ null && (['click']));\nvar useEventAway = function useEventAway(ref, callback, options) {\n  var callbackRef = useRef(callback);\n  useEffect(function () {\n    callbackRef.current = callback;\n  }, [callback]);\n  useEffect(function () {\n    var _ref = options || {},\n      _ref$eventNames = _ref.eventNames,\n      eventNames = _ref$eventNames === void 0 ? defaultEvents : _ref$eventNames,\n      rest = _objectWithoutProperties(_ref, _excluded);\n    var handler = function handler(event) {\n      if (ref.current && !ref.current.contains(event.target)) {\n        callbackRef.current(event);\n      }\n    };\n    eventNames.forEach(function (eventName) {\n      return document.addEventListener(eventName, handler, rest);\n    });\n    return function () {\n      eventNames.forEach(function (eventName) {\n        return document.removeEventListener(eventName, handler, rest);\n      });\n    };\n  }, [ref, options]);\n};\n/* harmony default export */ var es_useEventAway = ((/* unused pure expression or super */ null && (useEventAway)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useFavicon/index.js\n\nvar useFavicon = function useFavicon(href) {\n  useEffect(function () {\n    var link = document.querySelector(\"link[rel*='icon']\") || document.createElement('link');\n    link.type = 'image/x-icon';\n    link.rel = 'shortcut icon';\n    link.href = href;\n    document.getElementsByTagName('head')[0].appendChild(link);\n  }, [href]);\n};\n/* harmony default export */ var es_useFavicon = ((/* unused pure expression or super */ null && (useFavicon)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useHash/index.js\n\n\nvar useHash = function useHash() {\n  var _useState = useState(function () {\n      return window.location.hash;\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    hash = _useState2[0],\n    setHash = _useState2[1];\n  useEffect(function () {\n    var callback = function callback() {\n      setHash(window.location.hash);\n    };\n    window.addEventListener('hashchange', callback);\n    return function () {\n      window.removeEventListener('hashchange', callback);\n    };\n  }, []);\n  var write = useCallback(function (newHash) {\n    if (newHash !== hash) {\n      window.location.hash = newHash;\n    }\n  }, [hash]);\n  return [hash, write];\n};\n/* harmony default export */ var es_useHash = ((/* unused pure expression or super */ null && (useHash)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useHidden/index.js\n\n\nvar hiddenPropName = function hiddenPropName(document) {\n  if (typeof document.hidden !== 'undefined') {\n    return 'hidden';\n  } else if (typeof document.msHidden !== 'undefined') {\n    return 'msHidden';\n  } else if (typeof document.webkitHidden !== 'undefined') {\n    return 'webkitHidden';\n  }\n  return 'hidden';\n};\nvar getHidden = function getHidden() {\n  return document[hiddenPropName(document)];\n};\nvar useHidden = function useHidden() {\n  var _useState = useState(getHidden),\n    _useState2 = _slicedToArray(_useState, 2),\n    hidden = _useState2[0],\n    setHidden = _useState2[1];\n  useEffect(function () {\n    var callback = function callback() {\n      setHidden(getHidden());\n    };\n    document.addEventListener('visibilitychange', callback);\n    return function () {\n      document.removeEventListener('visibilitychange', callback);\n    };\n  }, []);\n  return hidden;\n};\n/* harmony default export */ var es_useHidden = ((/* unused pure expression or super */ null && (useHidden)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/history.js\n\nvar Action = /*#__PURE__*/function (Action) {\n  Action[\"Pop\"] = \"POP\";\n  Action[\"Push\"] = \"PUSH\";\n  Action[\"Replace\"] = \"REPLACE\";\n  return Action;\n}(Action || {});\nvar parsePath = function parsePath(path) {\n  var parsedPath = {};\n  if (path) {\n    var hashIndex = path.indexOf('#');\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substring(hashIndex);\n      path = path.substring(0, hashIndex);\n    }\n    var searchIndex = path.indexOf('?');\n    if (searchIndex >= 0) {\n      parsedPath.hash = path.substring(searchIndex);\n      path = path.substring(0, searchIndex);\n    }\n    parsedPath.pathname = path;\n  }\n  return parsedPath;\n};\nvar createLocation = function createLocation(current, to, state) {\n  return _objectSpread(_objectSpread({\n    pathname: typeof current === 'string' ? current : current.pathname,\n    hash: '',\n    search: ''\n  }, typeof to === 'string' ? parsePath(to) : to), {}, {\n    state: state\n  });\n};\nvar history_createHistory = function createHistory() {\n  var listener = null;\n  var action = Action.Pop;\n  var globalHistory = window.history;\n  var history = {\n    get location() {\n      var _window$location = window.location,\n        pathname = _window$location.pathname,\n        hash = _window$location.hash,\n        search = _window$location.search;\n      return createLocation('', {\n        pathname: pathname,\n        hash: hash,\n        search: search\n      });\n    },\n    listen: function listen(fn) {\n      var handlePop = function handlePop() {\n        var _listener;\n        var action = Action.Pop;\n        (_listener = listener) === null || _listener === void 0 ? void 0 : _listener({\n          action: action,\n          location: history.location\n        });\n      };\n      window.addEventListener('popstate', handlePop);\n      listener = fn;\n      return function () {\n        window.removeEventListener('popstate', handlePop);\n        listener = null;\n      };\n    },\n    replace: function replace(to, state) {\n      var _listener2;\n      action = Action.Push;\n      var location = createLocation(history.location, to, state);\n      var url = history.createHref(location);\n      globalHistory.pushState(state, '', url);\n      (_listener2 = listener) === null || _listener2 === void 0 ? void 0 : _listener2({\n        action: action,\n        location: history.location\n      });\n    },\n    push: function push(to, state) {\n      var _listener3;\n      action = Action.Push;\n      var location = createLocation(history.location, to, state);\n      var url = history.createHref(location);\n      globalHistory.pushState(state, '', url);\n      (_listener3 = listener) === null || _listener3 === void 0 ? void 0 : _listener3({\n        action: action,\n        location: history.location\n      });\n    },\n    createHref: function createHref(to) {\n      if (typeof to === 'string') {\n        return to;\n      }\n      var pathname = to.pathname,\n        search = to.search,\n        hash = to.hash;\n      var path = pathname;\n      if (search && search !== '') {\n        path += search.charAt(0) === '?' ? search : '?' + search;\n      }\n      if (hash && hash !== '#') {\n        path += hash.charAt(0) === '#' ? hash : '#' + hash;\n      }\n      return path;\n    },\n    go: function go(delta) {\n      globalHistory.go(delta);\n    }\n  };\n  return history;\n};\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useHistory/index.js\n\n\nvar useHistory_history;\nvar useHistory_useHistory = function useHistory() {\n  return useMemo(function () {\n    if (useHistory_history) {\n      return useHistory_history;\n    }\n    return useHistory_history = Object.freeze(createHistory());\n  }, []);\n};\n/* harmony default export */ var es_useHistory = ((/* unused pure expression or super */ null && (useHistory_useHistory)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useIntersection/index.js\n\n\n\nvar useIntersection = function useIntersection(ref, options) {\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    observerEntry = _useState2[0],\n    setObserverEntry = _useState2[1];\n  useEffect(function () {\n    if (ref.current && isFunction(IntersectionObserver)) {\n      var handler = function handler(entries) {\n        setObserverEntry(entries[0]);\n      };\n      var observer = new IntersectionObserver(handler, options);\n      observer.observe(ref.current);\n      return function () {\n        setObserverEntry(null);\n        observer.disconnect();\n      };\n    }\n  }, [ref.current, options === null || options === void 0 ? void 0 : options.root, options === null || options === void 0 ? void 0 : options.rootMargin, options === null || options === void 0 ? void 0 : options.threshold]);\n  return observerEntry;\n};\n/* harmony default export */ var es_useIntersection = ((/* unused pure expression or super */ null && (useIntersection)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useInterval/index.js\n\n\nvar useInterval_useInterval = function useInterval(fn, options) {\n  var callback = useLatest(fn);\n  var interval = useRef();\n  var run = useCallback(function () {\n    if (interval.current) {\n      clearInterval(interval.current);\n    }\n    interval.current = setInterval(function () {\n      var _callback$current;\n      (_callback$current = callback.current) === null || _callback$current === void 0 ? void 0 : _callback$current.call(callback);\n    }, (options === null || options === void 0 ? void 0 : options.delay) || 0);\n  }, []);\n  var clear = useCallback(function () {\n    if (interval.current) {\n      clearInterval(interval.current);\n    }\n  }, []);\n  useEffect(function () {\n    if (options !== null && options !== void 0 && options.immediate) {\n      run();\n    }\n  }, []);\n  return {\n    run: run,\n    clear: clear,\n    reset: run\n  };\n};\n/* harmony default export */ var es_useInterval = ((/* unused pure expression or super */ null && (useInterval_useInterval)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useLocation/index.js\n\n\n\n\nvar useLocation = function useLocation() {\n  var history = useHistory();\n  var _useState = useState(function () {\n      return _objectSpread({}, history.location);\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    location = _useState2[0],\n    setLocation = _useState2[1];\n  useEffect(function () {\n    var cancel = history.listen(function (_ref) {\n      var location = _ref.location;\n      setLocation(location);\n    });\n    return function () {\n      cancel();\n    };\n  }, []);\n  return location;\n};\n/* harmony default export */ var es_useLocation = ((/* unused pure expression or super */ null && (useLocation)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useLRU/index.js\n\n\n\n\n\nvar defaultMaxSize = 10;\nvar useLRU = function useLRU() {\n  var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMaxSize;\n  if (!isNumber(maxSize)) {\n    throw new Error('maxSize has to be a number, but got a ' + _typeof(maxSize));\n  }\n\n  // const [set, setCache] = useState<Map<K, V>>(new Map());\n\n  var cache = useRef(new Map());\n  var utils = useMemo(function () {\n    return {\n      maxSize: maxSize,\n      set: function set(key, value) {\n        if (cache.current.has(key)) {\n          cache.current.delete(key);\n        }\n        if (cache.current.size >= maxSize) {\n          var needDelKey = cache.current.keys().next().value;\n          cache.current.delete(needDelKey);\n        }\n        cache.current.set(key, value);\n      }\n    };\n  }, [maxSize]);\n  return _objectSpread({\n    has: function has(key) {\n      return cache.current.has(key);\n    },\n    peek: function peek(key) {\n      return cache.current.get(key);\n    },\n    get: function get(key) {\n      if (cache.current.has(key)) {\n        var _value = cache.current.get(key);\n        cache.current.delete(key);\n        cache.current.set(key, _value);\n        return _value;\n      }\n      return undefined;\n    },\n    delete: function _delete(key) {\n      return cache.current.delete(key);\n    },\n    clear: function clear() {\n      return cache.current.clear();\n    },\n    keys: function keys() {\n      return Array.from(cache.current.keys());\n    },\n    values: function values() {\n      return Array.from(cache.current.values());\n    },\n    entries: function entries() {\n      return Array.from(cache.current.entries());\n    },\n    pop: function pop() {\n      if (cache.current.size) {\n        var _cache$current$entrie = _slicedToArray(cache.current.entries().next().value, 2),\n          _key = _cache$current$entrie[0],\n          _value2 = _cache$current$entrie[1];\n        cache.current.delete(_key);\n        return _value2;\n      }\n      return undefined;\n    }\n  }, utils);\n};\n/* harmony default export */ var es_useLRU = ((/* unused pure expression or super */ null && (useLRU)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useMap/index.js\n\n\n\nvar useMap = function useMap(initValue) {\n  var _useState = useState(new Map(initValue)),\n    _useState2 = _slicedToArray(_useState, 2),\n    map = _useState2[0],\n    setMap = _useState2[1];\n  var actions = useMemo(function () {\n    return {\n      set: function set(key, value) {\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          newMap.set(key, value);\n          return newMap;\n        });\n      },\n      delete: function _delete(key) {\n        var result = false;\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          result = newMap.delete(key);\n          return newMap;\n        });\n        return result;\n      },\n      clear: function clear() {\n        setMap(function (prev) {\n          var newMap = new Map(prev);\n          newMap.clear();\n          return newMap;\n        });\n      },\n      setAll: function setAll(newValue) {\n        return setMap(new Map(newValue));\n      },\n      reset: function reset() {\n        return setMap(new Map(initValue));\n      }\n    };\n  }, [setMap]);\n  var utils = _objectSpread({\n    has: useCallback(function (key) {\n      return map.has(key);\n    }, [map]),\n    get: useCallback(function (key) {\n      return map.get(key);\n    }, [map])\n  }, actions);\n  return [map, utils];\n};\n/* harmony default export */ var es_useMap = ((/* unused pure expression or super */ null && (useMap)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useMemoizedFn/index.js\n\nvar useMemoizedFn = function useMemoizedFn(fn) {\n  var ref = useRef(fn);\n  ref.current = useMemo(function () {\n    return fn;\n  }, [fn]);\n  return useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current.apply(this, args);\n  }, []);\n};\n/* harmony default export */ var es_useMemoizedFn = ((/* unused pure expression or super */ null && (useMemoizedFn)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useMessage/index.js\n\n\nvar useMessage = function useMessage(listener) {\n  var _callback = useLatest(listener);\n  useEffect(function () {\n    var _listener = function _listener(message) {\n      _callback.current(message);\n    };\n    window.addEventListener('message', _listener, false);\n    return function () {\n      window.removeEventListener('message', _listener, false);\n    };\n  });\n};\n/* harmony default export */ var es_useMessage = ((/* unused pure expression or super */ null && (useMessage)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useMountedState/index.js\n\nvar useMountedState = function useMountedState() {\n  var ref = useRef(false);\n  useEffect(function () {\n    ref.current = true;\n  }, []);\n  return useCallback(function () {\n    return ref.current;\n  }, []);\n};\n/* harmony default export */ var es_useMountedState = ((/* unused pure expression or super */ null && (useMountedState)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/toString.js\n/* harmony default export */ var utils_toString = (Object.prototype.toString);\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/utils/isNetworkInformation.js\n\n/* harmony default export */ var utils_isNetworkInformation = (function (target) {\n  return toString.call(target) === '[object NetworkInformation]';\n});\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useNetwork/index.js\n\n\n\n\nvar getConnectionInfo = function getConnectionInfo() {\n  var nav = window.navigator;\n  var con = nav.connection || nav.webkitConnection || nav.mozConnection;\n  if (!isNetworkInformation(con)) {\n    return undefined;\n  }\n  return {\n    effectiveType: con === null || con === void 0 ? void 0 : con.effectiveType,\n    downlink: con === null || con === void 0 ? void 0 : con.downlink,\n    downlinkMax: con === null || con === void 0 ? void 0 : con.downlinkMax,\n    rtt: con === null || con === void 0 ? void 0 : con.rtt,\n    saveData: con === null || con === void 0 ? void 0 : con.saveData,\n    type: con === null || con === void 0 ? void 0 : con.type\n  };\n};\nvar useNetwork = function useNetwork() {\n  var _useState = useState(_objectSpread(_objectSpread({}, getConnectionInfo()), {}, {\n      online: window.navigator.onLine\n    })),\n    _useState2 = _slicedToArray(_useState, 2),\n    state = _useState2[0],\n    setState = _useState2[1];\n  useEffect(function () {\n    var changeOnlineState = function changeOnlineState(online) {\n      setState(function () {\n        return _objectSpread({\n          online: online\n        }, getConnectionInfo());\n      });\n    };\n    var onlineHandler = function onlineHandler() {\n      changeOnlineState(true);\n    };\n    var offlineHandler = function offlineHandler() {\n      changeOnlineState(false);\n    };\n    var changeHandler = function changeHandler() {\n      changeOnlineState(window.navigator.onLine);\n    };\n    window.addEventListener('online', onlineHandler);\n    window.addEventListener('offline', offlineHandler);\n    window.addEventListener('change', changeHandler);\n    changeHandler();\n    return function () {\n      window.removeEventListener('online', onlineHandler);\n      window.removeEventListener('offline', offlineHandler);\n      window.removeEventListener('change', changeHandler);\n    };\n  }, []);\n  return state;\n};\n/* harmony default export */ var es_useNetwork = ((/* unused pure expression or super */ null && (useNetwork)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/usePlatform/index.js\n\nvar usePlatform = function usePlatform() {\n  var utils = useMemo(function () {\n    var isSafari = function isSafari() {\n      return /Safari/i.test(navigator.userAgent);\n    };\n    // ios\n    var isIOS = function isIOS() {\n      return /iPhone|iPad|iPod/i.test(navigator.userAgent);\n    };\n    // ipados\n    var isIPadOS = function isIPadOS() {\n      return /iPad/i.test(navigator.userAgent) || /Macintosh/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1;\n    };\n    // android\n    var isAndroid = function isAndroid() {\n      return navigator.userAgent.indexOf('Android') > -1 || navigator.userAgent.indexOf('Adr') > -1;\n    };\n    var isMobile = function isMobile() {\n      if (isIPadOS()) {\n        return true;\n      }\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n    };\n    return {\n      isIOS: isIOS,\n      isSafari: isSafari,\n      isIPadOS: isIPadOS,\n      isAndroid: isAndroid,\n      isMobile: isMobile,\n      isFirefox: function isFirefox() {\n        return navigator.userAgent.indexOf('Firefox') > -1;\n      },\n      isWebKit: function isWebKit() {\n        return navigator.userAgent.indexOf('WebKit') > -1;\n      },\n      isChrome: function isChrome() {\n        return navigator.userAgent.indexOf('Chrome') > -1;\n      },\n      isOpera: function isOpera() {\n        return /Opera|OPR/.test(navigator.userAgent);\n      },\n      isMac: function isMac() {\n        return navigator.userAgent.indexOf('Mac') > -1;\n      },\n      isWindows: function isWindows() {\n        return navigator.userAgent.indexOf('Windows') > -1;\n      }\n    };\n  }, []);\n  return utils;\n};\n/* harmony default export */ var es_usePlatform = ((/* unused pure expression or super */ null && (usePlatform)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useQueue/index.js\n\n\n\nvar useQueue = function useQueue() {\n  var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var _useState = useState(initValues),\n    _useState2 = _slicedToArray(_useState, 2),\n    queue = _useState2[0],\n    setQueue = _useState2[1];\n  return {\n    pop: function pop() {\n      var first = queue[0];\n      setQueue(queue.slice(1));\n      return first;\n    },\n    push: function push(item) {\n      setQueue(function (prev) {\n        return [].concat(_toConsumableArray(prev), [item]);\n      });\n    },\n    get first() {\n      return queue[0];\n    },\n    get last() {\n      return queue[queue.length - 1];\n    },\n    get size() {\n      return queue.length;\n    }\n  };\n};\n/* harmony default export */ var es_useQueue = ((/* unused pure expression or super */ null && (useQueue)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useSet/index.js\n\n\n\nvar useSet = function useSet(initValue) {\n  var _useState = useState(new Set(initValue)),\n    _useState2 = _slicedToArray(_useState, 2),\n    set = _useState2[0],\n    setSet = _useState2[1];\n  var actions = useMemo(function () {\n    return {\n      add: function add(value) {\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          newSet.add(value);\n          return newSet;\n        });\n      },\n      delete: function _delete(value) {\n        var result = false;\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          result = newSet.delete(value);\n          return newSet;\n        });\n        return result;\n      },\n      clear: function clear() {\n        setSet(function (prev) {\n          var newSet = new Set(prev);\n          newSet.clear();\n          return newSet;\n        });\n      },\n      setAll: function setAll(newValue) {\n        return setSet(new Set(newValue));\n      },\n      reset: function reset() {\n        return setSet(new Set(initValue));\n      }\n    };\n  }, [setSet]);\n  var utils = _objectSpread({\n    has: useCallback(function (value) {\n      return set.has(value);\n    }, [set])\n  }, actions);\n  return [set, utils];\n};\n/* harmony default export */ var es_useSet = ((/* unused pure expression or super */ null && (useSet)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useStack/index.js\n\n\n\nvar useStack = function useStack() {\n  var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var _useState = useState(initValues),\n    _useState2 = _slicedToArray(_useState, 2),\n    stack = _useState2[0],\n    setStack = _useState2[1];\n  return {\n    pop: function pop() {\n      var first = stack[0];\n      setStack(stack.slice(1));\n      return first;\n    },\n    push: function push(item) {\n      setStack(function (prev) {\n        return [item].concat(_toConsumableArray(prev));\n      });\n    },\n    get first() {\n      return stack[0];\n    },\n    get size() {\n      return stack.length;\n    }\n  };\n};\n/* harmony default export */ var es_useStack = ((/* unused pure expression or super */ null && (useStack)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useStyle/index.js\n\n\nvar counter = 0;\nvar useStyle = function useStyle(css) {\n  var id = useMemo(function () {\n    return \"\".concat(projectName, \"-use-style-\") + counter++;\n  }, []);\n  var ref = useRef();\n  useEffect(function () {\n    if (!ref.current) {\n      var style = document.createElement('style');\n      style.id = id;\n      document.head.append(style);\n      ref.current = style;\n    }\n    ref.current.innerText = css;\n    return function () {\n      if (ref.current) {\n        document.head.removeChild(ref.current);\n      }\n    };\n  }, [css]);\n  return id;\n};\n/* harmony default export */ var es_useStyle = ((/* unused pure expression or super */ null && (useStyle)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useUpdate/index.js\n\n\nvar useUpdate_useUpdate = function useUpdate() {\n  var _useState = useState({}),\n    _useState2 = _slicedToArray(_useState, 2),\n    setUpdate = _useState2[1];\n  return useCallback(function () {\n    return setUpdate({});\n  }, []);\n};\n/* harmony default export */ var es_useUpdate = ((/* unused pure expression or super */ null && (useUpdate_useUpdate)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useTimeout/index.js\n\n\nvar useTimeout = function useTimeout() {\n  var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var updator = useUpdate();\n  return useTimeoutFn(updator, {\n    delay: delay,\n    immediate: true\n  });\n};\n/* harmony default export */ var es_useTimeout = ((/* unused pure expression or super */ null && (useTimeout)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useTitle/index.js\n\nvar useTitle = function useTitle(title) {\n  useEffect(function () {\n    document.title = title;\n  }, [title]);\n};\n/* harmony default export */ var es_useTitle = ((/* unused pure expression or super */ null && (useTitle)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useToggle/index.js\n\nvar toggleReducer = function toggleReducer(state, newValue) {\n  return typeof newValue === 'boolean' ? newValue : !state;\n};\nvar useToggle = function useToggle(initialValue) {\n  return useReducer(toggleReducer, typeof initialValue === 'boolean' ? initialValue : false);\n};\n/* harmony default export */ var es_useToggle = ((/* unused pure expression or super */ null && (useToggle)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useTyping/index.js\n\nvar isActiveElementEditable = function isActiveElementEditable() {\n  var _document = document,\n    activeElement = _document.activeElement;\n  if (!activeElement) {\n    return;\n  }\n  if (['INPUT', 'TEXTAREA'].includes(activeElement.tagName)) {\n    return true;\n  }\n  return activeElement.hasAttribute('contenteditable');\n};\nvar useTyping = function useTyping(onTyping, ref) {\n  useEffect(function () {\n    var handler = function handler(event) {\n      return isActiveElementEditable() && onTyping(event);\n    };\n    var target = ref !== null && ref !== void 0 && ref.current ? ref.current : document;\n    target === null || target === void 0 ? void 0 : target.addEventListener('keydown', handler);\n    return function () {\n      target === null || target === void 0 ? void 0 : target.removeEventListener('keydown', handler);\n    };\n  }, [onTyping, ref]);\n};\n/* harmony default export */ var es_useTyping = ((/* unused pure expression or super */ null && (useTyping)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useUnmount/index.js\n\nvar useUnmount = function useUnmount(fn) {\n  useEffect(function () {\n    return fn;\n  }, []);\n};\n/* harmony default export */ var es_useUnmount = ((/* unused pure expression or super */ null && (useUnmount)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/useUpdateEffect/index.js\n\nvar useUpdateEffect = function useUpdateEffect(effect, deps) {\n  var first = useRef(true);\n  useEffect(function () {\n    if (!first.current) {\n      effect();\n    }\n  }, deps);\n  useEffect(function () {\n    first.current = false;\n  }, []);\n};\n/* harmony default export */ var es_useUpdateEffect = ((/* unused pure expression or super */ null && (useUpdateEffect)));\n;// CONCATENATED MODULE: ./node_modules/let-hooks/es/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/***/ })\n\n}]);"],"names":["self","push","__unused_webpack_module","__webpack_exports__","__webpack_require__","d","es_useEvent","MsgType","target","property","decorators","descriptor","context","desc","Action","_class","_descriptor","_descriptor2","_descriptor3","_descriptor4","_descriptor5","_class2","work_timer_descriptor","react","js_cookie_assign","i","arguments","length","source","key","init","converter","defaultAttributes","set","name","value","attributes","document","expires","Date","now","toUTCString","encodeURIComponent","replace","decodeURIComponent","escape","stringifiedAttributes","attributeName","split","cookie","write","Object","create","get","cookies","jar","parts","slice","join","found","read","e","remove","withAttributes","withConverter","freeze","path","classCallCheck","createClass","defineProperty","lazy_initialize_defineProperty","handleDescriptor","configurable","enumerable","initializer","ret","call","writable","utils_createDefaultSetter","lazyInitialize","_len","args","Array","_key","utils_decorate","utils_typeof","Symbol","iterator","obj","constructor","prototype","_initDefineProp","utils_applyDecoratedDescriptor","forEach","reverse","reduce","decorator","undefined","utils_toConsumableArray","arr","isArray","from","arr2","utils_defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","entryArgs","isDescriptor","hasOwnProperty","keys","l","apply","concat","Meta","_classCallCheck","instance","Constructor","META_KEY","utils_getOwnKeys","object","newValue","bind","fn","utils_warn","console","warn","override_typeof","_createClass","defineProperties","props","protoProps","staticProps","FUNCTION_REGEXP","autobind_toConsumableArray","SyntaxErrorReporter","parentKlass","childKlass","parentDescriptor","childDescriptor","override_classCallCheck","topic","_extractFunctionSignature","_this","toString","match","params","parentPropertySignature","childPropertySignature","_getTopic","_extractTopicSignature","parentTopic","childTopic","condition","msg","error","GENERIC_FUNCTION_ERROR","_this2","m","parentNotation","childNotation","autobind_defineProperty","getPrototypeOf","mapStore","autobindClass","klass","descs","autobindMethod","_ref","getBoundSuper","WeakMap","has","superStore","boundFn","readonly_handleDescriptor","time","timeEnd","profile_extends","assign","profile_slicedToArray","sliceIterator","_arr","_n","_d","_e","_s","_i","next","done","err","profile_defaultConsole","profile","profileEnd","profile_handleDescriptor","_ref2","_ref2$","prefix","_ref2$2","onceThrottleOrFunction","_ref2$3","__enabled","__warned","meta","profileLastRan","isBrowser","window","utils_isBrowser","webWorker","addEventListener","message","data","type","Create","$timer","setTimeout","postMessage","taskId","Execute","clearTimeout","wait","timer","Clear","timerId","taskSeed","createMsg","autobind","WorkerTimer","Z","Map","onMessage","callback","newTask","handler","taskMap","worker","clear","id","Number","isNaN","_this$taskMap$get","onmessage","event","task","_task$handler","_task","delete","defaultTarget","eventName","options","useEffect","removeEventListener"],"sourceRoot":""}