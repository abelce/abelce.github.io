{"pageProps":{"data":{"category":{"id":"cd4e8a1e-80d0-49d5-bbd6-d2bc7d7ce3e9","name":"前端"},"content":"> LRU是Least Recently Used的缩写，即最近最少使用，是一种常见的缓存置换算法，淘汰最久未使用的数据。\n\n\n### 实现思路\n\n1. 设定缓存的最大数据量maxSize\n\n2. 数据按照最近访问时间进行排序，最近访问的数据放在最后\n\n3. 访问时若数据存在则将数据移动到最后\n\n4. 添加数据时：\n\n   1. 数据存在，则移动到最后\n   2. 不存在，若队列中数据量已到最大值，删除第一个数据，再添加新数据；否则直接添加新数据\n\n   \n\n### 代码\n\n由于Map中的数据根据插入的时间具有先后顺序，所以这里使用map来实现；[测试地址](https://codesandbox.io/s/zen-ishizaka-zvkv9k?file=/src/index.js)\n\n```js\nclass LRU {\n  queue = new Map();\n\n  constructor(capacity = 10) {\n    // 设置容量\n    this.capacity = capacity;\n  }\n\n  // 获取数据\n  get(key) {\n    if (this.queue.has(key)) {\n      const value = this.queue.get(key);\n      this.queue.delete(key);\n      this.queue.set(key, value);\n      return value;\n    }\n    return undefined;\n  }\n\n  // 添加数据， 如果存在则移动位置；若数据已经满了，删除第一个元素后再添加\n  put(key, value) {\n    if (this.queue.has(key)) {\n      this.queue.delete(key);\n      this.queue.set(key, value);\n      return;\n    }\n\n    if (this.queue.size >= this.capacity) {\n      this.removeFirstItem();\n    }\n    this.queue.set(key, value);\n  }\n\n  // 删除第一个元素\n  removeFirstItem() {\n    if (this.queue.size) {\n      this.queue.delete(this.queue.keys().next().value);\n    }\n  }\n  // 删除数据\n  remove(key) {\n    if (this.queue.has(key)) {\n      this.queue.delete(key);\n    }\n  }\n}\n```\n\n#### 1. 来测试一把，设置容量为4：\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nconsole.log([...lru.queue.values()]);\n```\n\n输出:\n\n```js\n[1, 2, 3]\n```\n\n\n\n#### 2. 读取数据：\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nlru.get(1);\nconsole.log([...lru.queue.values()]);\n```\n\n输出:\n\n```js\n[2, 3, 1]\n```\n\n现在1现在在最后了。\n\n#### 3. 当数据超过容量后再插入数据\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nlru.put(4, 4);\nlru.put(5, 5);\nconsole.log([...lru.queue.values()]);\n```\n\n输出：\n\n```js\n [2, 3, 4, 5]\n```\n\n数据1被删除了.\n\n\n\n### 结束语\n\n上面就是一个简单版的LRU缓存实现，当然在实际使用中还需要结合自身的业务进行调整。\n\n","createTime":1657873351947,"creativeType":"original","description":"LRU是Least Recently Used的缩写，即最近最少使用，是一种常见的缓存置换算法，淘汰最久未使用的数据。\n\n\n 实现思路\n\n1. 设定缓存的最大数据量maxSize\n\n2. 数据按照最近访问时间进行排序，最近访问的数据放在最后\n\n3. 访问时若数据存在则将数据移动到最后\n\n4. 添加数据时：\n\n   1. 数据存在，则移动到最后\n   2. 不存在，若队列中数据量已到最大值","headerImg":"//file.vwood.xyz/2022/07/15/upload_ejrh8m2zcd0hc0rgf622bffi7v8lqbn5.jpg","id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","isDeleted":false,"likeCount":0,"name":"js 实现 LRU缓存","operator":{"avatar":"","description":"","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["LRU","js"],"updateTime":1658063913819,"viewCount":70},"id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","latestArticleList":[{"id":"112b22af-34de-4f2a-b12d-029b948e9550","name":"二叉树层序遍历","tags":[],"description":"","content":""},{"id":"b3c8f2ad-6fe6-4afb-b16d-ec7af9aa92e2","name":"iconfont-extract: 一个将iconfont图标转化为React组件的工具","tags":[],"description":"","content":""},{"id":"b8997e5c-988d-4f9b-9637-143bf0219042","name":"Macos已损坏，无法打开。 您应该将它移到废纸篓。","tags":[],"description":"","content":""},{"id":"26d50f26-364c-4989-a661-0dcbe063ad89","name":"前端原生API识别条形码","tags":[],"description":"","content":""},{"id":"fefb5ef1-b0be-441b-93c7-80907d0d4399","name":"Web Notifcation介绍","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}