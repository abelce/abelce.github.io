{"pageProps":{"data":{"category":{"id":"cd4e8a1e-80d0-49d5-bbd6-d2bc7d7ce3e9","name":"前端"},"content":"websocket作为即时通信工具在前端广泛使用，消息发送之后如何判断超时，肯定会想到使用`setTimeout`、`setInterval`，我也是这么想的，所以就用到了代码了。既然文章开头都这么写，那大概率会出问题(^^)。\n\n是的，真出问题了。心跳设置为`10s`发送一次，但是当浏览器长时间切换到其他页面后，会发现后端断开了ws的链接，查看日志发现由于前端长时间未发送心跳引起的。\n\n页面在被切到后台之后浏览器对非活跃标签进行了限制，所以定时器的延迟时间就不准了。后端长时间未收到心跳就断开链接。[MDN上“制定有助于后台页面性能的策略”](https://developer.mozilla.org/zh-CN/docs/Web/API/Page_Visibility_API#%E5%88%B6%E5%AE%9A%E6%9C%89%E5%8A%A9%E4%BA%8E%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%9A%84%E7%AD%96%E7%95%A5)可以看到不活跃标签页中的`setTimeout`和`iframe`中的`requestAnimationFrame`都会收到限制。\n\n### 如何解决问题\n既然主线程会收到限制，那么可以添加一个不受限制的线程。没错，说的就是`web worker`。将定时器放在worker中，到时间后通知主线程即可。由于worker数据传输过程中会被序列化所以咱们不能直接把定时器的回调函数传输过去，只能在主线程中做一次映射。\n\n下面咱们写一个简单的工具`TimerUtil`，只提供setTimeout方法。[演示地址](https://codesandbox.io/s/quizzical-curie-crbtv3?file=/src/App.tsx)。\n\n页面开始显示\"loading\":\n\n![](https://file.vwood.xyz/2022/09/18/upload_a7xdgo28gunu5246kobbk0k9pb0jq9fl.png)\n\n2s后显示\"hello\":\n\n![](https://file.vwood.xyz/2022/09/18/upload_whlcy7phfgwvv0qmm8hu3ti30wf8vecf.png)\n\n### 实现原理\n1. TimerUtil.setTimeout将业务的回调`timerHandle`存储在`task`中，将延时`timeout`发送到worker中，并将taskId返回给业务层，这里的taskId并不是真正的定时器id；\n2. worker收到消息后判断类型，然后开始计时，并把`timerId`发送回TimerUtil，TimerUtil收到之后将`timerId`存储到对应的task。\n3. worker中定时器结束后发送类型为`call`的消息，TImerUtil收到后，根据`taskId`找到`task`并执行`timerHandle`，最后删除task任务.\n4. 如果要手动clear任务，在TimerUtil中实现clearTimeout方法，根据taskId找到对应的task，获取对应的timerId，传递到worker中，worker调用系统的clearTimeout就可以清除任务了。\n\n`setIntveral`、`clearIntveral`的实现类似。\n","createTime":1663481674824,"creativeType":"original","description":"websocket作为即时通信工具在前端广泛使用，消息发送之后如何判断超时，肯定会想到使用setTimeout、setInterval，我也是这么想的，所以就用到了代码了。既然文章开头都这么写，那大概率会出问题(^^)。\n\n是的，真出问题了。心跳设置为10s发送一次，但是当浏览器长时间切换到其他页面后，会发现后端断开了ws的链接，查看日志发现由于前端长时间未发送心跳引起的。\n\n页面在被","headerImg":"","id":"204fab9b-434c-47fd-83cc-787a142e9309","isDeleted":false,"likeCount":0,"name":"前端websocket中定时器使用","operator":{"avatar":"//file.vwood.xyz/2023/06/11/upload_ssaf3w2dlo0xox7alrcrca1704a6j2fn.jpg","description":"","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["websocket","web workrer","setTimeout","setInterval"],"updateTime":1663483879905,"viewCount":3},"id":"204fab9b-434c-47fd-83cc-787a142e9309","latestArticleList":[{"id":"1fa715f2-3eb5-4d0c-ae41-71003570c781","name":"text-decoration","tags":[],"description":"","content":""},{"id":"cec72607-3ac8-4397-aaf3-ae0ef4fb1263","name":"Jotai使用笔记(一)","tags":[],"description":"","content":""},{"id":"972f320c-7f72-4d3e-b300-81899acb230a","name":"背包问题","tags":[],"description":"","content":""},{"id":"112b22af-34de-4f2a-b12d-029b948e9550","name":"二叉树层序遍历","tags":[],"description":"","content":""},{"id":"b3c8f2ad-6fe6-4afb-b16d-ec7af9aa92e2","name":"iconfont-extract: 一个将iconfont图标转化为React组件的工具","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}