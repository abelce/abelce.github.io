{"pageProps":{"current":5,"blogs":[{"content":"","createTime":1658501210059,"creativeType":"original","description":"在使用dumi进行组件开发过程时，编写好的组件在编译发版前需要在项目中测试功能是否完善，使用<code>npm link xxx</code>链接后，有时会出现react版本不一致错误，\n这是因为组件和渲染它的<code>react-com</code>副本中的react不相同引起的。\n\n使用\nshell\nnpm ls react\n\n会发现两个react版本\n\n这时可以通过\nsh","headerImg":"","id":"03b49f83-d393-4473-aacb-9b4e61651482","isDeleted":false,"likeCount":0,"name":"error TS2300: Duplicate identifier 'LibraryManagedAttributes'.","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658501210059,"viewCount":28},{"content":"","createTime":1636124983377,"creativeType":"translate","description":"Resize Observer是一个新的JavaScript API，与[Intersection Observer API](https:alligator.io/js/intersection-observer/)、[Mutation Observer](https:developer.mozilla.org/en-US/docs/Web/API/M","headerImg":"//file.vwood.xyz/2022/07/22/upload_odsabek8n9qsvcsinog18arw43lsts6b.jpg","id":"b91d22df-cec2-4ee0-b23b-89e7e43a3cc1","isDeleted":false,"likeCount":0,"name":"Resize Observer使用","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["Resize Observer"],"updateTime":1658498485974,"viewCount":200},{"content":"","createTime":1640183965789,"creativeType":"original","description":"经常在脚本编写中需要使用到模版tempalte，用来静态生成文件、代码，总结如下。\n\n template中define使用\n\n在使用编写template时可以使用{{define}}{{end}}来命名模版，在模版引入时直接使用命名即可，如下：\nheader.tpl\n\ntpl\n{{define header}}\n\theader demo\n{{end}}\n\n\narticle.tpl","headerImg":"","id":"dc34891b-d0b9-4d3b-8183-aff569cf3269","isDeleted":false,"likeCount":0,"name":"golang tempalte使用","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063991343,"viewCount":326},{"content":"","createTime":1650353584993,"creativeType":"original","description":"M1芯片安装依赖的时候会报错：\n\n\n<--- JS stacktrace --->\n\nFATAL ERROR: wasm code commit Allocation failed - process out of memory\n 1: 0x10431b740 node::Abort() [/Users/xxx/.nvm/versions/node/v14.16.0/bin/node]\n 2","headerImg":"","id":"d649dced-2061-462c-b9bb-cae7b8a28873","isDeleted":false,"likeCount":0,"name":"nodejs在M1报错","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063980293,"viewCount":185},{"content":"","createTime":1648286545073,"creativeType":"original","description":"js\n <a\n   href=\"skype:xxxx?chat\"\n \ttarget=\"_blank\"\n    rel=\"noreferrer\"\n    >\n</a   \n\n更换用户名即可","headerImg":"","id":"dca13c42-ae64-4bc6-b7ab-88bcfd223e53","isDeleted":false,"likeCount":0,"name":"js 打开skype","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063959005,"viewCount":189},{"content":"","createTime":1657873351947,"creativeType":"original","description":"LRU是Least Recently Used的缩写，即最近最少使用，是一种常见的缓存置换算法，淘汰最久未使用的数据。\n\n\n 实现思路\n\n1. 设定缓存的最大数据量maxSize\n\n2. 数据按照最近访问时间进行排序，最近访问的数据放在最后\n\n3. 访问时若数据存在则将数据移动到最后\n\n4. 添加数据时：\n\n   1. 数据存在，则移动到最后\n   2. 不存在，若队列中数据量已到最大值","headerImg":"//file.vwood.xyz/2022/07/15/upload_ejrh8m2zcd0hc0rgf622bffi7v8lqbn5.jpg","id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","isDeleted":false,"likeCount":0,"name":"js 实现 LRU缓存","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["LRU","js"],"updateTime":1658063913819,"viewCount":70},{"content":"","createTime":1653616647381,"creativeType":"original","description":"本文主要介绍自己在使用v2ray进行反向代理过程中。安装请参考官网[安装](https:www.v2ray.com/chapter_00/install.html)，主要实现通过中间服务器访问家里电脑上运行的服务。\n\n\n\n 原理\n\n- 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流","headerImg":"","id":"06a15352-9328-4916-9524-7d158dcf4088","isDeleted":false,"likeCount":0,"name":"v2ray反向代理","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["v2ray","代理"],"updateTime":1658063900096,"viewCount":188},{"content":"","createTime":1638107992736,"creativeType":"original","description":"css\n.text1 {\n/*单行*/\n\n  width:200px;\n  overflow:hidden;\n  text-overflow:ellipsis;\n  -o-text-overflow:ellipsis;\n  -webkit-text-overflow:ellipsis;\n  -moz-text-overflow:ellipsis;\n  white-space:nowrap;\n","headerImg":"","id":"a21482f9-6b85-4bdb-b652-19d115b9080d","isDeleted":false,"likeCount":0,"name":"css行数限制","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063885880,"viewCount":197},{"content":"","createTime":1650510288910,"creativeType":"original","description":"\n\n滚动加载数据就是说在达到某个条件的时候自动触发加载数据的动作，通常是滚动到页面底部的时候加载数据；\n\n代码如下：\n\njs\n  handleScroll = (e) ={\n    let layout = document.getElementById(\"layout\");\n\n    if (layout.clientHeight + layout.scrollTop >= layou","headerImg":"","id":"131d0d16-5692-403b-b949-87426c3d3f47","isDeleted":false,"likeCount":0,"name":"js 实现滚动加载数据","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063851344,"viewCount":181},{"content":"","createTime":1636124890100,"creativeType":"original","description":"\n本文主要是结合自己在学习中使用css来实现图片的宽高自适应，并给出相应的结局方案。\n\n 场景\n\n给定一系列图片，图片宽高不等，每行所展示的图片数量不等，如何实现图片的自适应。\n\n\n\n 实现方法\n\n聪明的你肯定会想到使用flex布局，并且设置flex-wrap: wrap。但如何做到自适应宽度呢：\n\n我们假设图片原始宽度、高度分别为width、heigh","headerImg":"//file.vwood.xyz/2022/07/11/upload_93g868jys6jvws4mixi2olc40hexurf4.jpg","id":"3891106a-2cff-4d0d-8efb-1930d43d48bc","isDeleted":false,"likeCount":0,"name":"如何使用css实现图片宽高自适应","operator":{"id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":[],"updateTime":1658063691299,"viewCount":203}],"latestBlogs":[{"id":"f9b88b86-08c8-46d7-9398-35520cae75e9","name":"overflow:clip和overflow-clip-margin的介绍","tags":[],"description":"","content":""},{"id":"28e7fc5d-ef66-4eed-858c-b2d600c1c5de","name":"display:contents","tags":[],"description":"","content":""},{"id":"8adc7054-20dc-4f73-bcea-f7365f91ed7c","name":"docker pull 慢","tags":[],"description":"","content":""},{"id":"705e62c8-4c77-47af-bee2-2cb4eabb7948","name":"jotai原理篇","tags":[],"description":"","content":""},{"id":"c3ba9cf2-9005-4911-8130-417f69c93161","name":"ssh: connect to host github.com port 22: Operation timed out","tags":[],"description":"","content":""},{"id":"465d4a37-264d-49d4-a94b-ac9d39ad6dc3","name":"AbortController","tags":[],"description":"","content":""},{"id":"1fa715f2-3eb5-4d0c-ae41-71003570c781","name":"text-decoration","tags":[],"description":"","content":""},{"id":"cec72607-3ac8-4397-aaf3-ae0ef4fb1263","name":"Jotai使用笔记(一)","tags":[],"description":"","content":""},{"id":"972f320c-7f72-4d3e-b300-81899acb230a","name":"背包问题","tags":[],"description":"","content":""},{"id":"112b22af-34de-4f2a-b12d-029b948e9550","name":"二叉树层序遍历","tags":[],"description":"","content":""}],"total":92},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}