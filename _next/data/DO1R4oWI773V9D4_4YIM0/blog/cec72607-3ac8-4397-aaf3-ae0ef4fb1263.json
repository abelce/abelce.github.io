{"pageProps":{"data":{"category":{"id":"cd4e8a1e-80d0-49d5-bbd6-d2bc7d7ce3e9","name":"前端"},"content":"# Jotai\n\n[Jotai](https://jotai.org/) 是一款轻量级的状态管理工具，大小只有2kb，支持 Typescript。\n\n\n## 1. Jotai的组成部分\n\n1. store: 主要用于数据的存储、依赖的收集和更新，已经更新通知\n2. atom：创建原子，或者衍生新的原子\n3. useAtom：将atom与视图关联起来(将atom与store链接起来，同时订阅store中atom得变化)\n4. Provider: 传图store来隔离数据，如果不传将使用默认store\n\n\n### 2 atom\n\n首先看一下atom的创建函数\n\n```ts\n// primitive atom\nfunction atom<Value>(initialValue: Value): PrimitiveAtom<Value>\n\n// read-only atom\nfunction atom<Value>(read: (get: Getter) => Value | Promise<Value>): Atom<Value>\n\n// writable derived atom\nfunction atom<Value, Update>(\n  read: (get: Getter) => Value | Promise<Value>,\n  write: (get: Getter, set: Setter, update: Update) => void | Promise<void>\n): WritableAtom<Value, Update>\n\n// write-only derived atom\nfunction atom<Value, Update>(\n  read: Value,\n  write: (get: Getter, set: Setter, update: Update) => void | Promise<void>\n): WritableAtom<Value, Update>\n```\n\n如上代码atom分为：原始atom、衍生atom、只读atom、只写atom，以及可读可写atom。\n\n```ts\nconst primitiveAtom = atom(initialValue)\nconst derivedAtomWithRead = atom(read)\nconst derivedAtomWithReadWrite = atom(read, write)\nconst derivedAtomWithWriteOnly = atom(null, write)\n```\n\n\n下面创建了原始atom `countAtom`，衍生atom `deriveAtom`，当countAtom中的值发生变化时deriveAtom的值会自动更新。\n\n```ts\nimport { atom } from 'jotai'\n\n// 原始atom\nconst countAtom = atom(10)\n// 衍生atom，依赖另一个atom\nconst deriveAtom = atom((get) => get(countAtom) * 2);\n// 只读\nconst readOnlyAtom = atom((get) => get(countAtom) * 2);\n// 只写\nconst writeOnlyAtom =  atom(null, (get, set, update) => set(countAtom, get(countAtom) * update));\n// 可读可写\nconst readWriteAtom = atom(\n  (get) => get(countAtom) * 2,\n  (get, set, update) => {\n    set(countAtom, update / 2)\n  }\n)\n```\n\n###  2.1 useAtom\n\nuseAtom用于读取atom状态中的值，atom的状态数据保存在store的WeakMap中。像React的useState一样，useAtom以元组的方式返回值和更新函数。\n\natom最初是没有值的，当atom第一次被useAtom使用时，初始值才会存储在state中。如果atom是衍生的，read函数将会被调用以此来计算初始值。当atom不再被使用时，意味着所有使用它的组件都被卸载了，状态中值将被垃圾回收。\n\n```ts\nconst [value, setValue] = useAtom(countAtom)\n```\n\n如果只是想获取atom的值，不需要修改，可以使用 `useAtomValue`:\n\n```ts\nconst count = useAtomValue(countAtom)\n```\n\n同理，如果只想更新atom，不需要获取值，使用 `useSetAtom`:\n\n```ts\n const setCount = useSetAtom(countAtom)\n```\n\n## 3 store\n\n在store中存储atom的状态，store可以作为value传入`Provider`，store提供如下三个方法：\n\n+ get：获取atom的值\n+ set：设置atom的值\n+ sub：订阅atom的更新，当atom值发生改变后会调用订阅的函数， `useAtomValue`的源码中就通过该方法来触发组件的更新。\n\n```ts\nconst myStore = createStore()\n\nconst Root = () => (\n  <Provider store={myStore}>\n    <App />\n  </Provider>\n)\n```\n\n如果没有提供`Provier`，就会使用默认的store，称为**Provider-less**模式。\n默认store创建函数：\n```ts\nconst defaultStore = getDefaultStore()\n```\n\n以`useAtomValue`、`useSetAtom`举例，其中都会使用`useStore`，useStore如果没有传入store并且StoreContext中也没store的话就使用默认store。源码如下：\n\n```ts\nconst StoreContext = createContext<Store | undefined>(undefined)\n\nexport const useStore = (options?: Options): Store => {\n  const store = useContext(StoreContext)\n  return options?.store || store || getDefaultStore()\n}\n```\n\n没使用`Provider`组件时，StoreContext的值为undefined，这时就调用`getDefaultStore`获取默认store。\n\n## Provider\nProvider组件使用React Context为组件的子树提供状态，多个Provider可以为多个子树提供状态，并且可以嵌套使用。\n如果atom没有在provider下使用，就使用默认store，称之为Provider-less模式。\n\nProvider的作用有一下三点：\n1. 为不同的子树提供不同的状态。\n2. 接受atom的初始值\n3. 通过重新挂载清除所有原子\n\n```ts\nconst SubTree = () => (\n  <Provider>\n    <Child />\n  </Provider>\n)\n```\nProvider的类型签名\n```ts\nconst Provider: React.FC<{\n  store?: Store\n}>\n```\n\natom的值并不在atom自身，而是保存在对应的store中，Provider是一个包含store并为子组件的atom提供值的组件。如果需要给不同的子树提供不同的atom值设置Provider是很有必要的。\n\n举例：\n```ts\n// app.tsx\nconst myStore = createStore()\n\nconst Root = () => (\n  <Provider store={myStore}>\n    <App />\n  </Provider>\n)\n```\n\n```ts\n// component.tsx\nconst Component = () => {\n  const store = useStore()\n  const [count, setCount] = useAtom(countAtom, {store})\n  // ...\n}\n```\n\nuseStore的第二个参数可以指定从哪个store中获取atom的值，如果不传就从StoreContext中取，StoreContext中没有就使用默认的store。","createTime":1691330904692,"creativeType":"original","description":" Jotai\n\n[Jotai](https:jotai.org/) 是一款轻量级的状态管理工具，大小只有2kb，支持 Typescript。\n\n\n 1. Jotai的组成部分\n\n1. store: 主要用于数据的存储、依赖的收集和更新，已经更新通知\n2. atom：创建原子，或者衍生新的原子\n3. useAtom：将atom与视图关联起来(将atom与store链接起来，同时订阅stor","headerImg":"//file.vwood.xyz/2023/08/06/upload_p0goez6tgiqkwnh83e9qbyecr2m0ju5q.png","id":"cec72607-3ac8-4397-aaf3-ae0ef4fb1263","isDeleted":false,"likeCount":0,"name":"Jotai使用笔记(一)","operator":{"avatar":"//file.vwood.xyz/2023/06/11/upload_ssaf3w2dlo0xox7alrcrca1704a6j2fn.jpg","description":"","email":"abelce@163.com","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorId":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["Jotai","React"],"updateTime":1691331301523,"viewCount":0},"id":"cec72607-3ac8-4397-aaf3-ae0ef4fb1263","latestArticleList":[{"id":"0517a4cb-be8a-47a5-b7c2-da7904a4ba67","name":"docker使用postgres","tags":[],"description":"","content":""},{"id":"cd89eea1-6839-499b-8573-5a487afc48ef","name":"babel配置文件加载","tags":[],"description":"","content":""},{"id":"ef3bf6e0-6e9f-4704-8b9d-cdd4d1fa7a91","name":"typescript使用","tags":[],"description":"","content":""},{"id":"7b2f60f3-7b3e-4889-8062-30323d2af5cf","name":"git设置超时设置","tags":[],"description":"","content":""},{"id":"fac66413-5460-4a89-93dd-2a287ee1d14e","name":"babel配置文件加载过程","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}