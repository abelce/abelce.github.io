{"pageProps":{"data":{"category":{"id":"6d568d6d-b1ef-4170-8530-3c6199eb0a05","name":"状态管理"},"content":"\n## 介绍\n[Jotai](https://jotai.org/docs/introduction)是一种原子化的状态管理方案。采用的 `Atom` + `hook` + `Context`的方式来解决React的数据管理。\n\n当`Atom`更新的时候不会触发Context的更新，只会更新订阅了`Atom`的组件。\n\nJotai 有一个非常小的 API，并且是面向 TypeScript 的。 它与 React 的集成 useState hook 一样简单易用，但所有状态都是全局可访问的，派生状态易于实现，并且自动消除了额外的重新渲染\n\n同时还提供了`jotai/utils`，这些函数增加了对在 localStorage（或 URL 哈希）中保留原子状态、在服务器端渲染期间混合原子状态、创建具有 set 函数（包括类似 Redux 的 reducers 和 action 类型）的原子等等的支持！\n\n特征:\n  + 核心API只有2KB\n  + 很多的实用工具和集成\n  + 对TypeScript友好\n  + 适用于 Next.js、Gatsby、Remix 和 React Native\n  + 使用 SWC 和 Babel 插件响应快速刷新\n\n本文基于jotai v2.2.1版本。\n\n## 使用\n\n[例子](https://github.com/pmndrs/jotai/tree/main/examples)\n\n#### 创建atom\n\n```ts\nimport { atom } from 'jotai'\n\nconst countAtom = atom(0)\n```\n\n在组件中使用\n```tsx\nimport { useAtom } from 'jotai'\n\nfunction Counter() {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <h1>\n      {count}\n      <button onClick={() => setCount((c) => c + 1)}>add</button>\n    </h1>\n    )\n}\n```\n\n#### 衍生atom\n\n```tsx\nconst doubledCountAtom = atom((get) => get(countAtom) * 2)\n\nfunction DoubleCounter() {\n  const [doubledCount] = useAtom(doubledCountAtom)\n  return <h2>{doubledCount}</h2>\n}\n```\n从多个atom衍生\n\n```ts\nconst count1 = atom(1)\nconst count2 = atom(2)\nconst count3 = atom(3)\n\nconst sum = atom((get) => get(count1) + get(count2) + get(count3))\n```\n\n#### 可读可写atom\n默认atom就是可读可写的\n\n```ts\nconst decrementCountAtom = atom(\n  (get) => get(countAtom),\n  (get, set, _arg) => set(countAtom, get(countAtom) - 1)\n)\n```\n\n#### 只读atom\n\n```ts\nconst readOnlyAtom = atom((get) => get(countAtom) * 2)\n```\n\n#### 只写atom\n\n```ts\nconst multiplyCountAtom = atom(null, (get, set, by) =>\n  set(countAtom, get(countAtom) * by)\n)\n```\n\n#### useAtomValue\n获取atom的值\n```ts\nconst count = useAtomValue(countAtom)\n```\n\n#### useSetAtom\n设置atom的值\n```ts\nconst setCount = useSetAtom(countAtom)\n```\n\n## 工具函数\nJotai提供了一些使用的工具函数，方便业务使用。\n### 本地存储 [atomWithStorage](https://jotai.org/docs/utilities/storage)\n支持将数据持久化到本地\n\n[在线例子](https://codesandbox.io/s/jotai-persistence-vuwi7?from-embed=&file=/src/app.js:181-196)\n\n### 缓存 [atomFamily](https://jotai.org/docs/utilities/family)\n使用atomFamily复用已存在的atom \n\n### 数组 [splitAtom](https://jotai.org/docs/utilities/split)\n对数据项自动进行atom包装，同时提供了`remove`、`insert`和`move`操作\n\n## atom\natom函数用于创建atom配置，紧紧只是一个配置对象，不保存atom的值(原始atom会将默认值保存在init中)，atom对象是不可变的，值保存在store中，通过`store.get`获取\n\n```ts\nconst countAtom = atom(10);\n```\n\natom源码:\n\n```ts\nexport function atom<Value, Args extends unknown[], Result>(\n  read: Value | Read<Value, SetAtom<Args, Result>>,\n  write?: Write<Args, Result>\n) {\n  // atom的key，可以在React中作为组件的key使用\n  const key = `atom${++keyCount}`\n  const config = {\n    toString: () => key,\n  }\n  if (typeof read === 'function') {\n    // read是函数表示是一个衍生的atom\n    config.read = read\n  } else {\n    // read为非函数类型\n    config.init = read\n    config.read = (get) => get(config)\n    // 设置默认的write，设置当前atom的值\n    config.write = ((get: Getter, set: Setter, arg: SetStateAction<Value>) =>\n      set(config, typeof arg === 'function' ? arg(get(config)) : arg))\n  }\n  if (write) {\n    // 覆盖默认的write\n    config.write = write\n  }\n  return config\n}\n\n```\n上面的代码可以看出atom的一些特征：\n1. 每个atom都有一个唯一的`key`，并重写了config的toString方法（可以直接在React组件中将atom作为key使用）。\n2. read参数不为函数时，设置默认的read=(get) => get(config)读取atom自身的值。\n3. atom默认的`write`函数是修改自身的值，所以原始atom是可读可写的，衍生的atom没有没有默认write方法。\n4. 原始atom的初始值保存在`init`中，并且不能修改。\n\n\n## useAtom\n\nuseAtom使用atom与store结合起来的桥梁,使用 `useAtomValue`读取值、`useSetAtom`设置atom的值\n![upload_tilhjximg25aw5dm3pdm4zzl6o9302ye.webp](https://raw.githubusercontent.com/abelce/blogs/master/jotai/upload_tilhjximg25aw5dm3pdm4zzl6o9302ye.webp)\n\n\nuseAtomValue代码如下：\n\n```ts\nexport function useAtomValue<Value>(atom: Atom<Value>, options?: Options) {\n  const store = useStore(options)\n  \n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n      (prev) => {\n        const nextValue = store.get(atom)\n        if (\n          Object.is(prev[0], nextValue) &&\n          prev[1] === store &&\n          prev[2] === atom\n        ) {\n          // 如果前后两次value、store、atom都一样，返回上一次修改的值\n          return prev\n        }\n        return [nextValue, store, atom]\n      },\n      undefined,\n      () => [store.get(atom), store, atom]\n    )\n\n  let value = valueFromReducer\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    // store或者atom不一致时重新计算值\n    rerender()\n    value = store.get(atom)\n  }\n\n  const delay = options?.delay\n  useEffect(() => {\n    // 订阅后每次修改都会触发该函数，从而调用useReducer的dispatch来更新react组件\n    const unsub = store.sub(atom, () => {\n      // xxxx\n      rerender()\n    })\n    rerender()\n    return unsub\n  }, [store, atom, delay])\n\n  // xxxx\n  return isPromiseLike(value) ? use(value) : (value as Awaited<Value>)\n}\n\n```\n\nuseReducer返回的结果就是 `[[value, store, atom], rerender]`，其中value为atom的值，store为atom所属的store，rerender是useReducer的dispatch函数(每次value发生改变就会执行rerender来更新组件的值)。\n\nuseEffect通过`store.sub`订阅了atom，当atom的状态更改时触发，然后执行rerender来更新组件的值。`store.sub`返回取消订阅函数，组件卸载时取消订阅。\n\n可以看出  `useAtomValue` 主要干了两件事：\n\n1. 比较reducer和sore中的值，一致就返回reducer的值，否则返回store中的值\n2. 订阅store中atom的状态，来触发reducer的执行。\n\n\nuseSetAtom的源码:\n```ts\nexport function useSetAtom<Value, Args extends any[], Result>(\n  atom: WritableAtom<Value, Args, Result>,\n  options?: Options\n) {\n  const store = useStore(options)\n  const setAtom = useCallback(\n    (...args: Args) => {\n      // xxx \n      return store.set(atom, ...args)\n    },\n    [store, atom]\n  )\n  return setAtom\n}\n\n```\n通过`store.set`设置atom的值。\n\n\n## store\nstore用于保存atom的value，以及atom之间的依赖关系，在Jotai中store是可以通过存在多个，如果没有设置store，会创建一个默认的store。\nstore有三个常用的方法：\n\n+ get: 获取atom的值，上面 `useAtomValue` 中使用过\n+ set：设置值，useSetAtom使用来更新atom\n+ sub：订阅atom，atom状态更新时调用\n![upload_fjkayvw2bab4ud43pxtj6z710plmljg9.png](https://raw.githubusercontent.com/abelce/blogs/master/jotai/upload_fjkayvw2bab4ud43pxtj6z710plmljg9.webp)\n\n\nstore中atom的依赖关系，atomB可以通过atomA衍生而来，当atomA发生变化时，atomB会自动更新，如下:\n\n```ts\nconst atomA = atom(10);\nconst atomB = atom((get) => get(atomA)); // atomA更新时atomB会自动更新\n// xxxx\nstore.get(atomA)\nstore.get(atomB);\nstore.set(atomA, 20); // 更新数据\n```\n\nstore中维护了 atomA与atomB之间的依赖关系：\n\n+ dependency: atomB依赖atomA，atomA是atomB的dependency，维护在atomB的state上(atomState.d中)，原始atom的dependency中有存在atom自身\n+ dependent: atomB依赖atomA，atomB是atomA的dependent中，位置在mounted中（mounted.t中）\n\n通过上面的关系，atomA更新时能找到atomB，从而更新atomB的状态。\n\natom state结构:\n\n```ts\ntype AtomState<Value = AnyValue> = {\n  d: Dependencies\n} & ({ e: AnyError } | { v: Value })\n```\n\n+ d是维护atom的dependency，`type Dependencies = Map<AnyAtom, AtomState>`\n+ e: 错误信息\n+ v: atom的值\n\nMounted结构，只有在设置atom的值后，才会将\n```ts\ntype Mounted = {\n  /** The list of subscriber functions. */\n  l: Listeners\n  /** Atoms that depend on *this* atom. Used to fan out invalidation. */\n  t: Dependents\n  /** Function to run when the atom is unmounted. */\n  u?: OnUnmount\n}\n\n```\n\n+ l: atom的监听函数，useAtomValue中通过store.sub订阅的函数存放在这里\n+ t: 维护上面提到的dependent\n\n\n\n### store.get\n\n\n```ts\n  const readAtom = <Value>(atom: Atom<Value>): Value =>\n    returnAtomValue(readAtomState(atom))\n```\n\n查找atom的state，并从state中读取value，returnAtomValue:\n\n```ts\nconst returnAtomValue = <Value>(atomState: AtomState<Value>): Value => {\n  // xxxx\n  return atomState.v\n}\n```\n\nreadAtomState源码:\n\n```ts\nconst readAtomState = <Value>(atom: Atom<Value>): AtomState<Value> => {\n    // 从atomStateMap获取atom的state\n    const atomState = getAtomState(atom)\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          // 计算依赖的atomState\n          readAtomState(a)\n        }\n      })\n      // 如果所依赖的所有atom和对应的state没有变化，就直接返回map中的state\n      if (Array.from(atomState.d).every(\n          ([a, s]) => a === atom || getAtomState(a) === s\n        )) {\n        return atomState\n      }\n    }\n    // Compute a new state for this atom.\n    const nextDependencies: NextDependencies = new Map()\n    let isSync = true\n    const getter: Getter = <V>(a: Atom<V>) => {\n      if ((a as AnyAtom) === atom) {\n        // 如果依赖的是atom本身，\n        const aState = getAtomState(a)\n        // 先在atomStateMap上查找state\n        if (aState) {\n          nextDependencies.set(a, aState)\n          return returnAtomValue(aState)\n        }\n        // 如果stateMap上没有数据，就返回init\n        if (hasInitialValue(a)) {\n          nextDependencies.set(a, undefined)\n          return a.init\n        }\n        // NOTE invalid derived atoms can reach here\n        throw new Error('no atom init')\n      }\n      // a !== atom\n      const aState = readAtomState(a)\n      // 设置依赖\n      nextDependencies.set(a, aState)\n      // 返回a的value\n      return returnAtomValue(aState)\n    }\n    // xxxxxxxx\n    try {\n      // 调用read函数，收集依赖和获取value\n      const valueOrPromise = atom.read(getter, options as any)\n      return setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () =>\n        controller?.abort()\n      )\n    } catch (error) {\n      return setAtomError(atom, error, nextDependencies)\n    } finally {\n      isSync = false\n    }\n  }\n\n```\n\n1. 如果atomState存在，就遍历atomState.d并获取没有mount的依赖，最后判断每个依赖的state和其最新的state是否相等，相等就表示当前的atom的依赖都没发生变化，所以atomState也没变，返回atomState即可。\n\n2. atomState不存在，执行 atom.read 获取value，同时通过nextDependencies收集依赖\n\n  1. 如果getter的参数 a=== atom，表示依赖atom本身， 创建atom的时候read不是function，使用默认的read函数![77280644fdf69943e13f1dac211f69a9.png](https://raw.githubusercontent.com/abelce/blogs/master/jotai/77280644fdf69943e13f1dac211f69a9.png)\n\n  2. a !== atom时，获取依赖a的state并起value\n\n3. 调用 `setAtomValueOrPromise(atom, valueOrPromise, nextDependencies, () =>controller?.abort())`，设置atom的value和dependencies。\n\nsetAtomValueOrPromise中调用setAtomValue\n\n```ts\n  const setAtomValueOrPromise = <Value>(\n    atom: Atom<Value>,\n    valueOrPromise: Value,\n    nextDependencies?: NextDependencies,\n    abortPromise?: () => void\n  ): AtomState<Value> => {\n    // .........\n    // 设置atom的value\n    return setAtomValue(atom, valueOrPromise, nextDependencies)\n  }\n```\n\n继续看setAtomValue\n\n```ts\n  const setAtomValue = <Value>(\n    atom: Atom<Value>,\n    value: Value,\n    nextDependencies?: NextDependencies\n  ): AtomState<Value> => {\n    const prevAtomState = getAtomState(atom)\n    const nextAtomState: AtomState<Value> = {\n      d: prevAtomState?.d || new Map(),\n      v: value,\n    }\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies)\n    }\n    if (\n      prevAtomState &&\n      isEqualAtomValue(prevAtomState, nextAtomState) &&\n      prevAtomState.d === nextAtomState.d\n    ) {\n      // 如果v和d都相等，直接返回以前的state\n      // bail out\n      return prevAtomState\n    }\n    if (\n      prevAtomState &&\n      hasPromiseAtomValue(prevAtomState) &&\n      hasPromiseAtomValue(nextAtomState) &&\n      isEqualPromiseAtomValue(prevAtomState, nextAtomState)\n    ) {\n      if (prevAtomState.d === nextAtomState.d) {\n        // bail out\n        return prevAtomState\n      } else {\n        // restore the wrapped promise\n        nextAtomState.v = prevAtomState.v\n      }\n    }\n    // 设置新的state\n    setAtomState(atom, nextAtomState)\n    return nextAtomState\n  }\n\n```\n\n没有就会创建新的state对象nextAtomState，依赖`d`默认使用旧的`prevAtomState?.d || new Map()`，使用nextDependencies更新依赖\n\n```ts\n const nextAtomState: AtomState<Value> = {\n      d: prevAtomState?.d || new Map(),\n      v: value,\n    }\n    if (nextDependencies) {\n      updateDependencies(atom, nextAtomState, nextDependencies)\n    }\n```\n\n下一步比较 prevAtomState 和 nextAtomState，如果`v`和`d`都相等，返回 prevAtomState ，否则调用setAtomState更新atomState\n\nsetAtomState会将atom的prevAtomState放在pendingMap中，\n\n\n\n### store.set\n\nset过程分为两部分：\n\n1. 修改atomState\n2. 通过pendingMap刷新依赖中的`t`(dependent)数据，通过触发通过`store.sub`的订阅函数\n\n\nwriteAtomState函数：\n\n```ts\n  const writeAtomState = <Value, Args extends unknown[], Result>(\n    atom: WritableAtom<Value, Args, Result>,\n    ...args: Args\n  ): Result => {\n    let isSync = true\n    const getter: Getter = <V>(a: Atom<V>) => returnAtomValue(readAtomState(a))\n    const setter: Setter = <V, As extends unknown[], R>( a: WritableAtom<V, As, R>, ...args: As ) => {\n      let r: R | undefined\n      // 如果修改atom自身的值\n      if ((a as AnyWritableAtom) === atom) {\n        // ......\n        const prevAtomState = getAtomState(a)\n        // 设置新的value\n        const nextAtomState = setAtomValueOrPromise(a, args[0] as V)// 跟store.get过程中一样\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n           // value不相等，重新计算dependents\n          recomputeDependents(a)\n        }\n      } else {\n        // 修改依赖的atom，一直递归到最顶层的原始atom\n        r = writeAtomState(a as AnyWritableAtom, ...args) as R\n      }\n      // 如果atom.write是异步函数\n      if (!isSync) {\n        // 刷新pendingMap，重新设置mountedMap中的mounted的t数据\n        const flushed = flushPending()\n        // ......\n      }\n      return r as R\n    }\n    const result = atom.write(getter, setter, ...args)\n    isSync = false\n    return result\n  }\n```\n\n如果更新atom自身，直接通过setAtomValueOrPromise设置新值，然后等信atom的dependent；否则递归调用writeAtomState直到依赖项是原始atom，原始atom更新时就会更新dependent。\n\nflushPending函数：\n```typescript\n\n  const flushPending = (): void | Set<AnyAtom> => {\n    let flushed: Set<AnyAtom>\n    if (import.meta.env?.MODE !== 'production') {\n      flushed = new Set()\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap)\n      pendingMap.clear()\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom)\n        if (atomState) {\n          if (atomState.d !== prevAtomState?.d) {\n            // 如果依赖不一致，更新依赖\n            mountDependencies(atom, atomState, prevAtomState?.d)\n          }\n          const mounted = mountedMap.get(atom)\n          if (\n            mounted &&\n            !(\n              // TODO This seems pretty hacky. Hope to fix it.\n              // Maybe we could `mountDependencies` in `setAtomState`?\n              (\n                prevAtomState &&\n                !hasPromiseAtomValue(prevAtomState) &&\n                (isEqualAtomValue(prevAtomState, atomState) ||\n                  isEqualAtomError(prevAtomState, atomState))\n              )\n            )\n          ) {\n            // 前后两次state不一致时，触发监听函数（store.sub订阅的回调），调用set方法，组件更新就是这里触发的\n            mounted.l.forEach((listener) => listener())\n            // xxxx\n          }\n        } else if (import.meta.env?.MODE !== 'production') {\n          // xxx\n        }\n      })\n    }\n    // xxx\n  }\n```\n\n从中可以看到，依赖发生变化时调用`mountDependencies`函数更新mounted中的`t`，先从dependents中删除atom，然后将新的atom添加到对应的dependents中。\n`mountDependencies`执行后，通过`isEqualAtomValue`比较atom的值，如果发生变化就触发监听函数`mounted.l.forEach((listener) => listener())`，listener是通过`store.sub`添加，在`useAtomValue`就是通过`store.sub `来触发组件更新。\n\n```typescript\n  const mountDependencies = <Value>(\n    atom: Atom<Value>,\n    atomState: AtomState<Value>,\n    prevDependencies?: Dependencies\n  ): void => {\n    const depSet = new Set(atomState.d.keys())\n    prevDependencies?.forEach((_, a) => {\n      if (depSet.has(a)) {\n        // not changed\n        depSet.delete(a)\n        return\n      }\n      const mounted = mountedMap.get(a)\n      if (mounted) {\n        // 从被依赖项中的dependent中删除atom，表示不依赖了\n        mounted.t.delete(atom) // delete from dependents\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a)\n        }\n      }\n    })\n    // 在新的依赖项中添加dependent\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a)\n      if (mounted) {\n        mounted.t.add(atom) // add to dependents\n      } else if (mountedMap.has(atom)) {\n         // xxx\n        // 如果a是第一次被依赖，添加新的mounted对象\n        mountAtom(a, atom)\n      }\n    })\n  }\n```\n","createTime":1692453681241,"creativeType":"original","description":"\n 介绍\n[Jotai](https:jotai.org/docs/introduction)是一种原子化的状态管理方案。采用的 Atom + hook + Context的方式来解决React的数据管理。\n\n当Atom更新的时候不会触发Context的更新，只会更新订阅了Atom的组件。\n\nJotai 有一个非常小的 API，并且是面向 TypeScript 的。 它","headerImg":"//file.vwood.xyz/2023/08/20/upload_sv0wcr8j84x8y9atlbdl8yhz6w85vpgs.png","id":"705e62c8-4c77-47af-bee2-2cb4eabb7948","isDeleted":false,"likeCount":0,"name":"jotai原理篇","operator":{"avatar":"//file.vwood.xyz/2023/06/11/upload_ssaf3w2dlo0xox7alrcrca1704a6j2fn.jpg","description":"","email":"abelce@163.com","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorId":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["jotai","状态管理"],"updateTime":1699773548753,"viewCount":0},"id":"705e62c8-4c77-47af-bee2-2cb4eabb7948","latestArticleList":[{"id":"460fb164-5722-4cc2-ad6b-c35d5be4a670","name":"js提取iconfont项目的图标","tags":[],"description":"","content":""},{"id":"0517a4cb-be8a-47a5-b7c2-da7904a4ba67","name":"docker使用postgres","tags":[],"description":"","content":""},{"id":"cd89eea1-6839-499b-8573-5a487afc48ef","name":"babel配置文件加载","tags":[],"description":"","content":""},{"id":"ef3bf6e0-6e9f-4704-8b9d-cdd4d1fa7a91","name":"typescript使用","tags":[],"description":"","content":""},{"id":"7b2f60f3-7b3e-4889-8062-30323d2af5cf","name":"git设置超时设置","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}