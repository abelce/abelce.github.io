{"pageProps":{"data":{"category":{"id":"cd4e8a1e-80d0-49d5-bbd6-d2bc7d7ce3e9","name":"前端"},"content":"> LRU是Least Recently Used的缩写，即最近最少使用，是一种常见的缓存置换算法，淘汰最久未使用的数据。\n\n\n### 实现思路\n\n1. 设定缓存的最大数据量maxSize\n\n2. 数据按照最近访问时间进行排序，最近访问的数据放在最后\n\n3. 访问时若数据存在则将数据移动到最后\n\n4. 添加数据时：\n\n   1. 数据存在，则移动到最后\n   2. 不存在，若队列中数据量已到最大值，删除第一个数据，再添加新数据；否则直接添加新数据\n\n   \n\n### 代码\n\n由于Map中的数据根据插入的时间具有先后顺序，所以这里使用map来实现；[测试地址](https://codesandbox.io/s/zen-ishizaka-zvkv9k?file=/src/index.js)\n\n```js\nclass LRU {\n  queue = new Map();\n\n  constructor(capacity = 10) {\n    // 设置容量\n    this.capacity = capacity;\n  }\n\n  // 获取数据\n  get(key) {\n    if (this.queue.has(key)) {\n      const value = this.queue.get(key);\n      this.queue.delete(key);\n      this.queue.set(key, value);\n      return value;\n    }\n    return undefined;\n  }\n\n  // 添加数据， 如果存在则移动位置；若数据已经满了，删除第一个元素后再添加\n  put(key, value) {\n    if (this.queue.has(key)) {\n      this.queue.delete(key);\n      this.queue.set(key, value);\n      return;\n    }\n\n    if (this.queue.size >= this.capacity) {\n      this.removeFirstItem();\n    }\n    this.queue.set(key, value);\n  }\n\n  // 删除第一个元素\n  removeFirstItem() {\n    if (this.queue.size) {\n      this.queue.delete(this.queue.keys().next().value);\n    }\n  }\n  // 删除数据\n  remove(key) {\n    if (this.queue.has(key)) {\n      this.queue.delete(key);\n    }\n  }\n}\n```\n\n#### 1. 来测试一把，设置容量为4：\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nconsole.log([...lru.queue.values()]);\n```\n\n输出:\n\n```js\n[1, 2, 3]\n```\n\n\n\n#### 2. 读取数据：\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nlru.get(1);\nconsole.log([...lru.queue.values()]);\n```\n\n输出:\n\n```js\n[2, 3, 1]\n```\n\n现在1现在在最后了。\n\n#### 3. 当数据超过容量后再插入数据\n\n```js\nconst lru = new LRU(4);\nlru.put(1, 1);\nlru.put(2, 2);\nlru.put(3, 3);\nlru.put(4, 4);\nlru.put(5, 5);\nconsole.log([...lru.queue.values()]);\n```\n\n输出：\n\n```js\n [2, 3, 4, 5]\n```\n\n数据1被删除了.\n\n\n\n### 结束语\n\n上面就是一个简单版的LRU缓存实现，当然在实际使用中还需要结合自身的业务进行调整。\n\n","createTime":1657873351947,"creativeType":"original","description":"LRU是Least Recently Used的缩写，即最近最少使用，是一种常见的缓存置换算法，淘汰最久未使用的数据。\n\n\n 实现思路\n\n1. 设定缓存的最大数据量maxSize\n\n2. 数据按照最近访问时间进行排序，最近访问的数据放在最后\n\n3. 访问时若数据存在则将数据移动到最后\n\n4. 添加数据时：\n\n   1. 数据存在，则移动到最后\n   2. 不存在，若队列中数据量已到最大值","headerImg":"//file.vwood.xyz/2022/07/15/upload_ejrh8m2zcd0hc0rgf622bffi7v8lqbn5.jpg","id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","isDeleted":false,"likeCount":0,"name":"js 实现 LRU缓存","operator":{"avatar":"//file.vwood.xyz/2023/06/11/upload_ssaf3w2dlo0xox7alrcrca1704a6j2fn.jpg","description":"","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["LRU","js"],"updateTime":1658063913819,"viewCount":70},"id":"38abab46-1f1d-47e0-9f3d-aeafdf41a0e7","latestArticleList":[{"id":"8052bec4-7240-4068-864d-243e8b71d918","name":"自己打造的react hooks库: let-hooks","tags":[],"description":"","content":""},{"id":"da751d13-6717-41fd-a556-c311a1e24494","name":"overscroll-behavior阻止容器滚动","tags":[],"description":"","content":""},{"id":"f9b88b86-08c8-46d7-9398-35520cae75e9","name":"overflow:clip和overflow-clip-margin的介绍","tags":[],"description":"","content":""},{"id":"28e7fc5d-ef66-4eed-858c-b2d600c1c5de","name":"display:contents","tags":[],"description":"","content":""},{"id":"8adc7054-20dc-4f73-bcea-f7365f91ed7c","name":"docker pull 慢","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}