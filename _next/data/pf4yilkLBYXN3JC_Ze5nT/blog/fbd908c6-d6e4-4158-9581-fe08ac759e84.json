{"pageProps":{"data":{"category":{"id":"01c2bf92-d615-4600-9f0a-64db28de7345","name":"React"},"content":"本文介绍React更新的baseState，阐述baseState在updateQueue中的作用，以及工作原理。\n\n首先React中任务有着不同的优先级，优先级高的任务先执行，低的后执行。所以会出现先创建的任务后执行的情况。比如下面的例子：\n```\nA1 -> B2 -> C1 -> D2\n```\n其中数字越小优先级越高，所以`A1`和`C1` 会优先执行，执行完后的更新队列就如下：\n```\nB2 -> D2\n```\n\n假如每个任务对state的操作为如下：\n```\nconst [count, setCount] = useState(1)\nA1: setCount(count => count + 1)\nB2: setCount(count => count * 2)\nC1: setCount(count => count + 1)\nD2: setCount(count => count + 2)\n```\n首先如果不按照优先级，直接按照更新列表中任务的顺序执行，执行的过程就是\n```\nA: count = 1 + 1; //2\nB: count = 2 * 2; // 4\nC: count = 4 + 1; // 5\nD: count = 5 + 2; // 7\n```\n上面的执行结果为`count=7`\n\n如果按照优先级高的先执行，优先级低的后执行那么执行的顺序如下:\n```\n// 高优先级\nA1: count = 1 + 1; // 2\nC1: count = 2 + 1; // 3\n// 低优先级\nB2: count = 3 * 2; // 6\nD2: count = 6 + 2; // 8\n```\n执行结果为`count=8`，两种方式的执行结果竟然不一致。\n\n那么React时是怎么解决这个问题的呢?\n\n往下看。\n\n## baseState和baseUpdate\nreact在 updateQueue上用`baseState`、`firstBaseUpdate`、`lastBaseUpdate`来解决。\n\n这三个属性的作用：\n1. baseState：第一个被跳过的Update前一个Update的执行结果。\n2. firstBaseUpdate：第一个被跳过的Update\n3. lastBaseUpdate：最后一个Update，只要有Update被跳过，那么该元素就指向updateQueue的最后一个节点。\n   \n下面看一下processUpdateQueue源码的执行逻辑。\n\n### 将新的update追加到现有的baseUpdate后面\n\n```js\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate; // 上次执行后的第一个baseUpdate\n  let lastBaseUpdate = queue.lastBaseUpdate; // 上次执行后的最后一个\n\n  // Check if there are pending updates. If so, transfer them to the base queue.\n  let pendingQueue = queue.shared.pending; // 本次待处理的update\n  if (pendingQueue !== null) {\n    \n    queue.shared.pending = null;\n\n    // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    /**\n     * 将pending update 追加到 base update上 \n     * */ \n    if (lastBaseUpdate === null) {\n      /**\n       * 如果baseUpdate没有数据，就是说上一次没有出现跳过某个update的情况，那么就将 firstBaseUpdate就为pendingUpdate的第一个节点 \n       */\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n    /**\n     * lastBaseUpdate 设置为pendingUpdate的最后一个update\n     */\n    lastBaseUpdate = lastPendingUpdate;\n\n    /**\n     * current 也做上面同样的处理\n     */\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  }\n```\n每次处理update时都要从上一次第一个跳过的位置开始计算，比如计算`B2`时要用`A1`的结果`2`作为初始值，而不是`C1`的结果`3`；同时将新的update追加在后面，这样最终的执行顺序才是正确的。\n\n\n### 执行baseUpdate\n```js\n   // 如果存在上次跳过的Update，就执行该逻辑\n  // 如果baseUpdate存在相同或者更高的优先级的任务，就执行优先级对应的任务\n  if (firstBaseUpdate !== null) {\n    let newState = queue.baseState;\n    let newLanes = NoLanes;\n\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n\n    let update = firstBaseUpdate;\n    // 开始处理update\n    do {\n      const updateLane = update.lane;\n      const updateEventTime = update.eventTime;\n      // \n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        /**\n         * 将优先级不够的任务添加到新的firstBaseUpdate上，执行结束后添加到fiber的updateQueue的firstBaseUpdate上\n         */\n        const clone: Update<State> = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n\n          next: null,\n        };\n        if (newLastBaseUpdate === null) {\n          /**\n           * 第一个跳过的update作为新的firstBaseUpdate，后面会放在udpateQueue上\n           */\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          /**\n           * 第一个跳过的任务的前一个任务的执行后的state\n           */\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        /**\n         * 如果优先级足够，就执行update\n         */\n        if (newLastBaseUpdate !== null) {\n          /**\n           * 如果newLastBaseUpdate存在，说明前面又跳过的Update，后续的所有Update又要重新形成baseUpdate\n           */\n          const clone: Update<State> = {\n            eventTime: updateEventTime,\n            lane: NoLane,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: null,\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n\n        /**\n         * 处理update后得到新的state\n         */\n        newState = getStateFromUpdate(\n          workInProgress,\n          queue,\n          update,\n          newState,\n          props,\n          instance,\n        );\n        const callback = update.callback;\n        if (\n          callback !== null &&\n          // If the update was already committed, we should not queue its\n          // callback again.\n          update.lane !== NoLane\n        ) {\n          workInProgress.flags |= Callback; // 标记这个fiber需要执行state更新后的回调\n          const effects = queue.effects; // 收集副作用，放到update上\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n      update = update.next; \n      if (update === null) { \n        /**\n         * 如果baseUpdate执行完了，判断是否又产生了新的update\n         */\n        pendingQueue = queue.shared.pending;\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue;\n          // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n    \n    /**\n     * 执行完毕后将 baseState、firstBaseUpdate和lastBaseUpdate设置到updateQueue上\n     */\n    queue.baseState = ((newBaseState: any): State); \n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    const lastInterleaved = queue.shared.interleaved;\n    if (lastInterleaved !== null) {\n      let interleaved = lastInterleaved;\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = ((interleaved: any).next: Update<State>);\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n\n      queue.shared.lanes = NoLanes;\n    }\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes; // 将优先级不够的lanes放到节点的lanes上\n    /**\n     * 更新state\n    */\n    workInProgress.memoizedState = newState; // 设置新的state\n  }\n```\n每次处理update时都会先判断优先级：\n1. 如果优先级不够，就跳过。同时设置新的baseState，firstBaseUpdate，lastBaseUpdate.\n2. 如果优先级够：\n  1. 如果存在跳过的update，则该节点也要在baseUpdate上\n  2. 执行udpate，得到新的state\n  3. 将新的baseState、firstBaseUpdate、lastBaseUpdate添加到updateQueue上。\n\n\n## 总结\nreact使用baseUpdate和baseState来保证class组件中更新的正确性，因为react每次更新都会产生一个update，每个update的优先级不同；同时每个更新任务只会处理最高优先级的update，所以优先级低的就会跳过，下一次再处理。\n\n\n","createTime":1697639370378,"creativeType":"original","description":"本文介绍React更新的baseState，阐述baseState在updateQueue中的作用，以及工作原理。\n\n首先React中任务有着不同的优先级，优先级高的任务先执行，低的后执行。所以会出现先创建的任务后执行的情况。比如下面的例子：\n\nA1 -B2 -> C1 -> D2\n\n其中数字越小优先级越高，所以A1和C1 会优先执行，执行完后的更新队列就如下：\n\nB","headerImg":"","id":"fbd908c6-d6e4-4158-9581-fe08ac759e84","isDeleted":false,"likeCount":0,"name":"baseState与baseUpdate.md","operator":{"avatar":"//file.vwood.xyz/2023/06/11/upload_ssaf3w2dlo0xox7alrcrca1704a6j2fn.jpg","description":"","email":"abelce@163.com","github":"https://github.com/abelce","id":"96f16846-31f2-489c-9af0-d4ca13e836e4","name":"文钦"},"operatorID":"96f16846-31f2-489c-9af0-d4ca13e836e4","tags":["react","baseState","updateQueue"],"updateTime":1697728338268,"viewCount":0},"id":"fbd908c6-d6e4-4158-9581-fe08ac759e84","latestArticleList":[{"id":"2d304261-a68b-4cf2-bbab-56efec4ba707","name":"react动态插入样式","tags":[],"description":"","content":""},{"id":"6fb6e255-cf4e-46f7-b65a-7ee57793d305","name":"iframe在react中的使用","tags":[],"description":"","content":""},{"id":"faa29859-b26c-4737-af1c-f37ff0a7eafc","name":"依赖注入","tags":[],"description":"","content":""},{"id":"fbd908c6-d6e4-4158-9581-fe08ac759e84","name":"baseState与baseUpdate.md","tags":[],"description":"","content":""},{"id":"8052bec4-7240-4068-864d-243e8b71d918","name":"自己打造的react hooks库: let-hooks","tags":[],"description":"","content":""}]},"initialMobxState":{"userStore":{"currentUser":null,"users":[],"token":"","qiniuToken":"","userCount":0,"productCount":0,"commentCount":0,"settingType":"products"},"productStore":{"products":[],"total":0,"type":"","url":"","current":1,"product":null,"likesMap":{},"tabpane":"all","token":"","loading":false,"todayHunters":[],"today":[],"yesterday":[],"relatedProducts":[],"search":""},"commentStore":{"comments":[],"total":0,"current":0},"noteStore":{"token":"","notes":[],"total":0,"note":null},"askStore":{"token":"","asks":[],"total":0,"ask":null},"stypeStore":{"data":[]}},"__N_SSG":true}